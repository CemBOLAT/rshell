Time: 1715008666
Type: Directory
Name: gtu
Path: /
Time: 1704813029
Type: Directory
Name: math
Path: /gtu/
Time: 1704299052
Type: Regular
Name: Directory.hpp
Path: /gtu/math/
Time: 1704798764
Content: #ifndef DIRECTORY_HPP
# define DIRECTORY_HPP

#include "File.hpp"
#include <vector>

class Directory : public File {
	public:
		Directory(const string &name, time_t time, const string &path);
		Directory(const string &name, time_t time, const string &path, Directory* parentDirectory);
		Directory(const Directory& dir) = default;
		Directory&	operator=(const Directory& dir) = default;
		virtual				~Directory();

		Directory*			getDirectory(const string &name) const;
		void				addFile(File* file);
		Directory*			getParentDirectory() const { return this->parentDirectory; }
		void				setParentDirectory(Directory* parentDirectory) { this->parentDirectory = parentDirectory; }
		string				getOwnFilesPath() const { return this->ownFilesPath; }
		vector<File*>		&getFiles () { return this->files; }
		const vector<File*>	&getFiles () const { return this->files; }
		virtual void		print(ostream& os, size_t maxLen) const override;
		virtual void		save(ostream &os) const override;
		virtual void		cat() const override;
		virtual void		cd(Shell &shell) override;
		void				removeFile(const string &name);

		class Iterator {
			public:
				Iterator(vector<File *>::iterator it) : it(it) {}
				Iterator(vector<File *>::const_iterator it) : cit(it) {}
				Iterator(const Iterator& it) = default;
				Iterator&	operator=(const Iterator& it) = default;
				~Iterator() = default;
				File*		&operator*() { return *it; }
				const File* operator*() const { return *cit; }
				Iterator	&operator++() { ++it; return *this; }
				bool		operator==(const Iterator& it) const { return this->it == it.it; }
				bool		operator!=(const Iterator& it) const { return this->it != it.it; }
			private:
				std::vector<File*>::iterator		it;
				std::vector<File*>::const_iterator	cit;
		};

		Iterator	begin() const { return Iterator(files.begin()); }
		Iterator	cbegin() const { return Iterator(files.cbegin()); }
		Iterator	end() const { return Iterator(files.end()); }
		Iterator	cend() const { return Iterator(files.cend()); }

	private:
		string			ownFilesPath;
		vector<File*>	files;
		Directory*		parentDirectory;
};


#endif
Type: Regular
Name: Executor.hpp
Path: /gtu/math/
Time: 1704798907
Content: #ifndef EXECUTOR_HPP
# define EXECUTOR_HPP

# include "Shell.hpp"

namespace Executor {
	void	cat(const Shell& shell, const string& fileName);
	void	rm(const Shell& shell, const string& fileName);
	void	mkdir(const Shell& shell, const string& directoryName);
	void	cd(Shell& shell, const string& directoryName);
	void	ls(const Directory *directory, const Shell &shell, const string& option);
	void	cp(const Shell& shell, const string& source, const string& fileName);
	void	link(const Shell& shell, const string& source, const string& fileName);
}

#endif
Type: Regular
Name: File.hpp
Path: /gtu/math/
Time: 1704566046
Content: #ifndef FILE_HPP
# define FILE_HPP

#include <iostream>
#include <string>

using namespace std;

class Shell;

// load ve save kısmını da pure virtual yap
class File {
	public:
		File(const string &name, time_t time, const string& path = "");
		File(const File& file) = default;
		File&			operator=(const File& file) = default;
		virtual			~File() = 0;

		time_t			getTime() const { return this->time; }
		void			setTime(const time_t &time) { this->time = time; }

		string			getName() const { return this->name; }
		string			getPath() const { return this->path; }

		virtual void	print(ostream& os, size_t maxLen) const = 0;
		virtual void	save(ostream &os) const = 0;
		virtual void	cat() const = 0;
		virtual void	cd(Shell &shell) = 0;

		template <typename T>
		static T		*find(const Shell &shell, const string &name);
	private:
		const string	name;
		string 			path;
		time_t			time;

};


#endif
Type: Regular
Name: LoadFile.hpp
Path: /gtu/math/
Time: 1704299052
Content: #ifndef LOADFILE_HPP

#define LOADFILE_HPP

class Shell;

#include <iostream>
#include <fstream>

using namespace std;

class LoadFile{
	public:
		LoadFile() = delete;
		LoadFile(const LoadFile& other) = delete;
		LoadFile& operator=(const LoadFile& other) = delete;
		~LoadFile() = delete;

		static void		load(const std::string &path, Shell &shell);
		static void		addRegularFile(Shell &shell, ifstream &file);
		static void		addDirectory(Shell &shell, ifstream &file);
		static void		addSymbolicLink(Shell &shell, ifstream &file);
};

#endif
Type: Regular
Name: RegularFile.hpp
Path: /gtu/math/
Time: 1704798836
Content: #ifndef REGULARFILE_HPP
# define REGULARFILE_HPP

#include "File.hpp"
#include "Directory.hpp"

class RegularFile : public File {
	public:
		RegularFile(const string &name, size_t sizeBytes, time_t time, const string& data = "", const string& path = "");
		RegularFile(const RegularFile& file) = default;
		RegularFile&		operator=(const RegularFile& file) = default;
		virtual				~RegularFile();


		size_t				getSizeBytes() const { return this->sizeBytes; }
		const string		&getData() const { return this->data; }

		virtual void		print(ostream& os, size_t maxLen) const override;
		virtual void		save(ostream &os) const override;
		virtual void		cat() const override;
		virtual void		cd(Shell &shell) override;

		class Iterator {
			public:
				Iterator(string::iterator it) : it(it) {}
				Iterator(string::const_iterator it) : cit(it) {}
				Iterator(const Iterator& it) = default;
				Iterator&	operator=(const Iterator& it) = default;
				~Iterator() = default;
				char		&operator*() { return *it; }
				Iterator	&operator++() { ++it; return *this; }
				bool		operator==(const Iterator& it) const { return this->it == it.it; }
				bool		operator!=(const Iterator& it) const { return this->it != it.it; }
			private:
				string::iterator		it;
				string::const_iterator	cit;
		};
		Iterator	begin() const { return Iterator(data.begin()); }
		Iterator	end() const { return Iterator(data.end()); }
		Iterator	cbegin() const { return Iterator(data.cbegin()); }
		Iterator	cend() const { return Iterator(data.cend()); }
	private:
		size_t			sizeBytes;
		string			data;
};

#endif
Type: Regular
Name: SaveFile.hpp
Path: /gtu/math/
Time: 1704299052
Content: #ifndef SAVEFILE_HPP

#define SAVEFILE_HPP

class Shell;

#include <iostream>

class SaveFile{
	public:
		SaveFile() = delete;
		SaveFile(const SaveFile& other) = delete;
		SaveFile& operator=(const SaveFile& other) = delete;
		~SaveFile() = delete;

		static void	save(const std::string &path, Shell &shell);
};

#endif
Type: Regular
Name: Shell.hpp
Path: /gtu/math/
Time: 1704787391
Content: #ifndef SHELL_HPP
# define SHELL_HPP

#include "RegularFile.hpp"
#include "Utils.hpp"

class Directory;

class Shell {
	public:
		Shell();
		Shell(const Shell& shell) = default;
		Shell&	operator=(const Shell& shell) = default;

		~Shell();

		bool			isTerminated() const { return this->isTerminating; }
		void			setTerminated(bool isTerminated) { this->isTerminating = isTerminated; }
		void			setPrompt(const string& prompt) { this->prompt = prompt;}
		string			getPrompt() const { return this->prompt; }
		const string	getFileSystemPath() const { return Shell::fileSystemPath; }
		Directory*		getCurrentDirectory() const { return this->currentDirectory; }
		void			setCurrentDirectory(Directory* directory) { this->currentDirectory = directory; }
		Directory*		getRoot() const { return this->root; }
		void			execute(string command);
		size_t			getOsSize() const { return osSize; }
	private:
		static const string	fileSystemPath;
		Directory*			root;
		Directory*			currentDirectory;
		bool				isTerminating;
		string				prompt;
		static const size_t	osSize = 1024 * 1024 * 10;
};

//# include "../src/Template.cpp"

#endif
Type: Regular
Name: SymbolicLink.hpp
Path: /gtu/math/
Time: 1704566064
Content: #ifndef SYMBOLIC_LINK_HPP
#define SYMBOLIC_LINK_HPP

#include "File.hpp"
#include <string>

using std::string;

class SymbolicLink : public File
{
	public:
		SymbolicLink(const string& name, const string& path, time_t time, File* link, const string &linkedName, const string &linkPath);
		virtual ~SymbolicLink();
		virtual void	print(std::ostream& os, size_t maxLen) const override;

		File*				getLink() const { return this->link; }
		void				setLink(File* link) { this->link = link; }
		string				getLinkedName() const { return this->linkedName; }
		string				getLinkedPath() const { return this->linkPath; }
		virtual void		save(ostream &os) const override;
		//static SymbolicLink *find(const Shell &shell, const string &name, SymbolicLink *ptr);
		virtual void		cat() const override;
		virtual void		cd(Shell &shell) override;
	private:
		File*	link;
		string	linkedName;
		string	linkPath;
};

#endi
Type: Regular
Name: TextEngine.hpp
Path: /gtu/math/
Time: 1704299052
Content: #ifndef TEXT_ENGINE_HPP
#define TEXT_ENGINE_HPP

#include <string>

namespace Utils {
	namespace TextEngine {

		const std::string ANSI_RESET = "\033[0m";
		const std::string ANSI_BOLD = "\033[1m";
		const std::string ANSI_UNDERLINE = "\033[4m";
		const std::string ANSI_BLINK = "\033[5m";

		const std::string ANSI_FG_BLACK = "\033[30m";
		const std::string ANSI_FG_RED = "\033[31m";
		const std::string ANSI_FG_GREEN = "\033[32m";
		const std::string ANSI_FG_YELLOW = "\033[33m";
		const std::string ANSI_FG_BLUE = "\033[34m";
		const std::string ANSI_FG_MAGENTA = "\033[35m";
		const std::string ANSI_FG_CYAN = "\033[36m";
		const std::string ANSI_FG_WHITE = "\033[37m";

		const std::string ANSI_BG_BLACK = "\033[40m";
		const std::string ANSI_BG_RED = "\033[41m";
		const std::string ANSI_BG_GREEN = "\033[42m";
		const std::string ANSI_BG_YELLOW = "\033[43m";
		const std::string ANSI_BG_BLUE = "\033[44m";
		const std::string ANSI_BG_MAGENTA = "\033[45m";
		const std::string ANSI_BG_CYAN = "\033[46m";
		const std::string ANSI_BG_WHITE = "\033[47m";

		void	yellow();
		void	red();
		void	green();
		void	blue();
		void	reset();
		void	bold();
		void	underline();
		void	blink();
		void	black();
		void	magenta();
		void	cyan();
		void	orange();
		void	white();
		void	redBackground();
		void	greenBackground();
		void	blueBackground();
		void	yellowBackground();
		void	blackBackground();
		void	magentaBackground();
		void	cyanBackground();
		void	whiteBackground();
		void	resetBackground();
		void	resetForeground();
		void	resetAll();
	}
}

#endi
Type: Regular
Name: Utils.hpp
Path: /gtu/math/
Time: 1704787448
Content: #ifndef UTILS_HPP

# define UTILS_HPP

# include <string>
# include <vector>
# include <fstream>

class Directory;
class Shell;
class RegularFile;
class SymbolicLink;
class File;

using namespace std;

namespace Utils {
	std::string		trim(const std::string& str);
	std::string		getContent(std::ifstream &file);
	std::ostream&	printTime(std::ostream& os, struct tm* timeinfo);
	std::string		getData(std::ifstream &file);
	vector<string>	split(const string &str, char delim);
	string			relPathToAbsPath(const Shell &shell, const string &path);
	string			absPathToRelPath(const Shell &shell, const string &path);
	string			getParentPathOfAbsPath(const string &absPath);
	size_t			getProgramSize(const Shell &Shell);
	void			recheckLinks(Shell &shell, Directory *directory);
	void			printPrompt(const Shell &shell);
}

#endif
Type: Link
Name: link1
Path: /gtu/
Time: 1704799967
Link: /gtu/
LinkedName: link
Type: Link
Name: link2
Path: /gtu/
Time: 1704799970
Link: /gtu/
LinkedName: link1
Type: Link
Name: link
Path: /gtu/
Time: 1704800083
Link: /gtu/math/
LinkedName: Utils.hpp
Type: Directory
Name: cse
Path: /gtu/
Time: 1704812929
Type: Directory
Name: cse101
Path: /gtu/cse/
Time: 1704812939
Type: Directory
Name: hw_notes
Path: /gtu/cse/cse101/
Time: 1704299052
Type: Regular
Name: Directory.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704802991
Content: #include "../includes/Directory.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/Shell.hpp"
#include <ctime>		// std::localtime
#include <sstream>		// std::stringstream
#include <iomanip>		// std::setw
#include <stdexcept>	// std::runtime_error

// constructor for root directory
Directory::Directory(const string &name, time_t time, const string &path)
	: File(name, time, path), ownFilesPath("/"), parentDirectory(nullptr)
{
	files = vector<File *>();
}

// constructor for other directories
Directory::Directory(const string &name, time_t time, const string &path, Directory *parentDirectory)
	: File(name, time, path), ownFilesPath(path + name + "/"), parentDirectory(parentDirectory)
{
	files = vector<File *>();
}

// destructor : delete calls each files destructor and deletes them.
// then deletes itself.
Directory::~Directory()
{
	for (auto file : this->files)
		delete file;
}

// Preconditions: User wants to add a file to this directory.
// Postconditions: Adds file to files vector. <push_back>
void Directory::addFile(File *file)
{
	this->files.push_back(file);
}

// Preconditions: User wants to print the information about this directory with using ls or something.
// Postconditions: Prints the information about this directory. <colorful way>
void Directory::print(std::ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "D ";
	Utils::TextEngine::reset();
	Utils::TextEngine::bold();
	Utils::TextEngine::cyan();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();

	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::resetAll();
	os << std::endl;
}

// Preconditions : Progaram wants to save this directory to filesystem.txt file.
// Postconditions : Saves this directory to filesystem.txt file.
void Directory::save(std::ostream &file) const
{
	file << "Type: Directory" << std::endl;
	file << "Name: " << this->getName() << std::endl;
	file << "Path: " << this->getPath() << std::endl;
	file << "Time: " << this->getTime() << std::endl;
}

// Preconditions: User wants to cat this directory.
// Postconditions: Throws runtime_error.
void Directory::cat() const
{
	throw std::runtime_error("cat: " + this->getName() + ": Is a directory");
}

// Preconditions: User wants to remove a specific named file from this directory.
// Postconditions: Removes file from files vector and deletes it <erase>
void Directory::removeFile(const string &name)
{
	for (auto it = this->files.begin(); it != this->files.end(); ++it)
	{
		if ((*it)->getName() == name)
		{
			delete *it;
			this->files.erase(it);
			return;
		}
	}
}

// Preconditions: User wants to change current directory to this directory.
// Postconditions: Changes current directory to this directory.
void Directory::cd(Shell &shell)
{
	shell.setCurrentDirectory(this);
}
Type: Regular
Name: Executor.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704810937
Content: #include "../includes/Executor.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/File.hpp"
#include "../includes/Directory.hpp"
#include "./Template.cpp"
#include <ctime>
#include <sys/stat.h>
#include <fstream>
#include <dirent.h>
#include <sys/types.h>
#include <fcntl.h>
#include <iomanip>
#include <cstring>
#include <stdexcept>

//****************************************  LS  ****************************************//
namespace
{

	// Getting absolute path of a file only by its name while listing files
	string absPathToRelPath(const Shell &shell, const string &path)
	{
		return path.substr(shell.getCurrentDirectory()->getOwnFilesPath().size(), path.size() - 1);
	}
	// lisiting only current directory '.'
	void listOnlyCurrentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << "."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
	// listing parent directory '..'
	void listParentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getParentDirectory()->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << ".."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
}

namespace
{
	// returns max name length of files in directory to align
	size_t getMaxNameLength(const Directory *directory)
	{
		size_t maxNameLength = 2; // for '.' and '..'
		for (auto file : *directory)
		{
			if (file->getName().length() > maxNameLength)
				maxNameLength = file->getName().length();
		}
		return maxNameLength;
	}
}

namespace Executor
{
	// Precondition: User wants to execute ls command
	// Postcondition: ls command is executed
	// @param directory: current directory
	// @param option: option for ls command
	/*
		ls command is used to list files and directories in current directory.
		ls command's '-R' option has a special print format. Firstly it prints current directory's files and directories.
		Then it prints subdirectories' files and directories recursively.
	*/
	void ls(const Directory *directory, const Shell &Shell, const string &option)
	{
		size_t	maxNameLength = getMaxNameLength(directory); // for align
		listOnlyCurrentDirectory(cout, directory, maxNameLength); // listing '.' is a must for ls command
		if (directory != Shell.getRoot()) // listing '..' is a must except root directory
			listParentDirectory(cout, directory, maxNameLength);
		for (auto file : *directory)
			file->print(cout, maxNameLength);
		if (option == "-R")
		{
			for (auto file : *directory)
			{
				if (dynamic_cast<Directory *>(file))
				{
					Directory *directory = dynamic_cast<Directory *>(file);
					cout << "\n";
					Utils::TextEngine::orange();
					cout << "./" << absPathToRelPath(Shell, directory->getOwnFilesPath()) << ":";
					Utils::TextEngine::reset();
					cout << endl;
					ls(directory, Shell, option);
				}
			}
		}
	}
}

//****************************************  LS OVER ****************************************//

//****************************************  CAT  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute cat command
	// Postcondition: cat command is executed
	void cat(const Shell &shell, const string &fileName)
	{
		File	*filePtr = nullptr;

		if (fileName.empty())
			throw runtime_error("cat: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cat: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName); // get absolute path of file
			if (absPath == "/")
				throw runtime_error("cat: " + fileName + ": Is a directory"); // root directory cannot be printed
			filePtr = File::find<File>(shell, absPath);
			if (filePtr == nullptr)
				throw invalid_argument("cat: " + fileName + ": No such file or directory");
			filePtr->cat(); // <polymorphism>
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  CAT OVER ****************************************//

//****************************************  RM  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute rm command
	// Postcondition: rm command is executed
	void	rm(const Shell &shell, const string &fileName)
	{
		File		*filePtr = nullptr;
		Directory	*parentDirectory = nullptr;

		if (fileName.empty())
			throw runtime_error("rm: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("rm: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("rm: cannot remove '" + fileName + "': Is a directory"); // root directory cannot be deleted
			filePtr = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absPath));
			if (filePtr == nullptr)
				throw invalid_argument("rm: cannot remove '" + fileName + "': No such file or directory");
			if (dynamic_cast<Directory *>(filePtr))
				throw invalid_argument("rm: cannot remove '" + fileName + "': Is a directory"); // directory cannot be deleted as you said in pdf
			parentDirectory->removeFile(filePtr->getName()); // remove file from parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  RM OVER ****************************************//
//****************************************  MKDIR  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute mkdir command
	// Postcondition: mkdir command is executed
	// @brief : '' Makes or removes a directory '' as pdf says
	void mkdir(const Shell &shell, const string &fileName)
	{
		File		*directory = nullptr;
		Directory	*parentDirectory = nullptr;
		if (fileName.empty())
			throw runtime_error("mkdir: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists"); // root directory cannot be created and deleted
			string pPath = Utils::getParentPathOfAbsPath(absPath);
			if (pPath == "/")
				pPath = ""; // if parent directory is root directory, parent directory's path is empty
			directory = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, pPath);
			if (directory != nullptr) // delete if existent file is directory and throw exception if not
			{
				if (dynamic_cast<Directory *>(directory)) // if file is directory
				{
					parentDirectory->removeFile(absPath.substr(absPath.find_last_of('/') + 1)); // remove directory from parent directory
					parentDirectory->setTime(time(nullptr));
				}
				else
					throw invalid_argument("mkdir: cannot create directory '" + fileName + "': File exists"); // if file is not directory throw exception
				return;
			}
			else if (parentDirectory == nullptr) // if parent directory does not exist throw exception <for root directory parent directory manipulalated as root too at find function>
				throw invalid_argument("mkdir: cannot create directory '" + fileName + "': No such file or directory");
			string name = absPath.substr(absPath.find_last_of('/') + 1);
			if (parentDirectory == shell.getRoot()) // if parent directory is root directory
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath(), parentDirectory);
			else
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath() + parentDirectory->getName() + "/", parentDirectory);
			parentDirectory->addFile(directory); // add directory to parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}
//****************************************  MKDIR OVER ****************************************//
//****************************************  CD  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute cd command
	// Postcondition: cd command is executed
	// @brief : '' Changes the current directory '' as pdf says
	// @brief '.' and '..' are special cases for cd command and empty string is special case for cd command
	// @brief if directory is not existent throw exception
	void	cd(Shell &shell, const string &directoryName)
	{
		File	*directory = nullptr;
		if (directoryName.empty()) // if directory name is empty set current directory to root directory
			shell.setCurrentDirectory(shell.getRoot());
		else if (directoryName == ".") // if directory name is '.' do nothing
			return;
		else if (directoryName == "..") // if directory name is '..' set current directory to parent directory
		{
			if (shell.getCurrentDirectory() == shell.getRoot()) // if current directory is root directory do nothing
				return;
			shell.setCurrentDirectory(shell.getCurrentDirectory()->getParentDirectory());
		}
		else
		{
			try
			{
				string pPath = Utils::relPathToAbsPath(shell, directoryName);
				if (pPath == "/")
				{
					shell.setCurrentDirectory(shell.getRoot());
					return;
				}
				directory = File::find<File>(shell, pPath);
				if (directory == nullptr)
					throw invalid_argument("cd: " + directoryName + ": No such file or directory");
				directory->cd(shell); // <polymorphism>
			}
			catch (const invalid_argument &e)
			{
				throw e;
			}
		}
	}
}

// ****************************************  CD OVER ****************************************//
// ****************************************  CP  ****************************************//

namespace
{
	// Precondition: User wants to execute cp command and source is a regular file
	// Postcondition: cp command is executed and source is copied to destination
	// @brief : '' Copies file and directory from our original os '' as pdf says
	RegularFile	*copyRegularFile(const string &source, const string &fileName, const struct stat &sourceStat, const string &path)
	{
		ifstream	sourceFile(source);
		RegularFile	*regularFile;
		string		data, line;
		if (!sourceFile.is_open())
			throw runtime_error("cp: source file '" + source + "' does not exist");
		while (getline(sourceFile, line)) // read file line by line
		{
			data += line + "\n";
		}
		data = data.substr(0, data.size() - 2);
		data += static_cast<char>(3); // end of text character
		sourceFile.close();
		regularFile = new RegularFile(fileName, data.size(), sourceStat.st_mtime, data, path); // create regular file
		return regularFile;
	}
}

namespace
{
	// Precondition: User wants to execute cp command and source is a directory
	// Postcondition: cp command is executed and source is copied to destination
	Directory *copyDirectory(const string &source, const string &fileName, const Shell &shell, const struct stat &sourceStat, const string &path, Directory *parentDirectory)
	{
		Directory	*directory; // directory to be copied

		DIR *copiedDir = opendir(source.c_str()); // open directory
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		struct dirent *entry; // entry of directory
		directory = new Directory(fileName, sourceStat.st_mtime, path, parentDirectory); // create directory
		while ((entry = readdir(copiedDir)) != nullptr) // read the directory until end
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) // ignore '.' and '..'
			{
				std::string entryPath = source + "/" + entry->d_name; // get entry's path

				struct stat entryStat; // entry's stat
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'"); // if stat cannot be accessed throw exception and exit
				}
				if (S_ISREG(entryStat.st_mode))
				{
					// Copy regular file
					RegularFile *regularFile = copyRegularFile(entryPath, entry->d_name, entryStat, directory->getOwnFilesPath());
					directory->addFile(regularFile); // add regular file to directory
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					// Recursively copy subdirectories
					Directory *subDirectory = copyDirectory(entryPath, entry->d_name, shell, entryStat, directory->getOwnFilesPath(), directory);
					directory->addFile(subDirectory); // add subdirectory to directory
				}
			}
		}
		closedir(copiedDir); // close directory
		return (directory);
	}
}

namespace
{
	// Precondition: User wants to execute cp command so program gets the size of directory
	// Postcondition: Returns the size of directory
	size_t getDirectorySize(const struct stat &sourcestat, const string &source)
	{
		DIR *copiedDir = opendir(source.c_str());
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		(void)sourcestat; // unused
		struct dirent *entry;
		size_t size = 0;
		while ((entry = readdir(copiedDir)) != nullptr)
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0)
			{
				std::string entryPath = source + "/" + entry->d_name;

				struct stat entryStat;
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'");
				}

				if (S_ISREG(entryStat.st_mode))
				{
					size += entryStat.st_size;
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					size += getDirectorySize(entryStat, entryPath); // recursively get subdirectories' size
				}
			}
		}
		closedir(copiedDir);
		return (size);
	}
}

namespace
{
	// Precondition: User wants to execute cp command
	// Postcondition: cp command is executed and source is copied to destination
	void onlyAddToDirectory(const Shell &shell, const string &source, const string &fileName, const struct stat &sourceStat)
	{

		if (S_ISREG(sourceStat.st_mode))
		{
			RegularFile *regularFile = copyRegularFile(source, fileName, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath());
			shell.getCurrentDirectory()->addFile(regularFile);
			shell.getCurrentDirectory()->setTime(time(nullptr));
		}
		else if (S_ISDIR(sourceStat.st_mode))
		{
			Directory *directory = copyDirectory(source, fileName, shell, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath(), shell.getCurrentDirectory());
			shell.getCurrentDirectory()->addFile(directory);
		}
		shell.getCurrentDirectory()->setTime(time(nullptr));
	}
}

namespace Executor
{
	// Precondition: User wants to execute cp command
	// Postcondition: program executes cp command
	void cp(const Shell &shell, const string &source, const string &fileName)
	{

		struct stat	sourceStat;
		File		*file = nullptr;

		if (source.empty() || fileName.empty())
			throw runtime_error("cp: missing operand");
		if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists");
		if (stat(source.c_str(), &sourceStat) != 0)
		{
			throw std::runtime_error("cp: source file '" + source + "' does not exist"); // if stat cannot be accessed throw exception and exit
		}
		file = File::find<File>(shell, shell.getCurrentDirectory()->getOwnFilesPath() + fileName);
		if (file != nullptr)
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists"); // if file exists throw exception
		if (S_ISREG(sourceStat.st_mode) && sourceStat.st_size + Utils::getProgramSize(shell) > shell.getOsSize()) // size of file + size of program > size of os
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		if (S_ISDIR(sourceStat.st_mode) && getDirectorySize(sourceStat, source) + Utils::getProgramSize(shell) > shell.getOsSize())
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		onlyAddToDirectory(shell, source, fileName, sourceStat); // add file to current directory
	}
}

// ****************************************  CP OVER ****************************************//
// ****************************************  LINK  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute link command
	// Postcondition: program executes link command
	void link(const Shell &shell, const string &source, const string &dest)
	{
		Directory		*destDirectory = nullptr;
		Directory		*sourceDirectory = nullptr;
		File			*sourceFile = nullptr;
		File			*destFile = nullptr;
		SymbolicLink	*symbolicLink = nullptr; // symbolic link to be created

		string absSourcePath = Utils::relPathToAbsPath(shell, source);
		string absDestPath = Utils::relPathToAbsPath(shell, dest);
		if (dest.empty() || source.empty())
			throw runtime_error("link: missing operand");
		else if (dest == "." || dest == ".." || dest == "/")
			throw runtime_error("link: cannot create link '" + dest + "': File exists");
		try
		{
			destFile = File::find<File>(shell, absDestPath);
			destDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absDestPath));
			if (destDirectory == nullptr) // if destination directory does not exist throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': No such file or directory");
			if (destFile != nullptr) // if destination file exists throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': File exists");
			sourceFile = File::find<File>(shell, absSourcePath);
			sourceDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absSourcePath));
			if (sourceDirectory == nullptr){
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), Utils::getParentPathOfAbsPath(absSourcePath) + "/");
			}
			else {
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), sourceDirectory->getOwnFilesPath());
			}
			destDirectory->addFile(symbolicLink); // add symbolic link to destination directory
			destDirectory->setTime(time(nullptr)); // set destination directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

// ****************************************  LINK OVER ****************************************//
Type: Regular
Name: File.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704805811
Content: #include "../includes/File.hpp"

File::File(const string &name, time_t time, const string& path)
	: name(name) , path(path) ,time(time)
{/*Body inintentionally left empty! */}


File::~File()
{/*Body inintentionally left empty! */}
Type: Regular
Name: LoadFile.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704806200
Content: #include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include <fstream>
#include <string>
#include <ctime>
#include <sstream>
#include <stdexcept>

using namespace std;

// Precondition: program wants to load regular file
// Postcondition: regular file is loaded
void LoadFile::addRegularFile(Shell &shell, ifstream &file)
{
	string name, path, time, data;
	Directory *directory = shell.getRoot();
	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	data = Utils::getData(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		directory = shell.getRoot();
		directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
		return;
	}
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem may not be configrated ! ");
	directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
}

// Precondition: program wants to load directory
// Postcondition: directory is loaded
void LoadFile::addDirectory(Shell &shell, ifstream &file)
{
	string name, path, time;
	Directory *parentDirectory;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		parentDirectory = shell.getRoot();
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
	else
	{
		parentDirectory = File::find<Directory>(shell, path);
		if (parentDirectory == nullptr)
			throw runtime_error("Directory coould not be found.");
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
}

// Precondition: program wants to load symbolic link
// Postcondition: symbolic link is loaded
void LoadFile::addSymbolicLink(Shell &shell, ifstream &file)
{
	string name, path, time, linkPath, linkerName;
	File *link = nullptr;
	Directory *directory = nullptr;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	linkPath = Utils::getContent(file);
	linkerName = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	link = File::find<File>(shell, linkPath + linkerName);
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem file is broken"); // not configrated
	directory->addFile(new SymbolicLink(name, path, time_t_time, link, linkerName, linkPath));
}

// Precondition: program wants to load file system
// Postcondition: file system is loaded
void LoadFile::load(const std::string &path, Shell &shell)
{
	ifstream file(path);

	if (!file.is_open())
		throw runtime_error("File could not be opened.");
	string lineTmp;			// to ignore first line for roots time
	getline(file, lineTmp); // ignore first line
	while (!file.eof())
	{
		string line;
		getline(file, line);
		line = Utils::trim(line);
		if (line.empty())
			continue;
		if (line.substr(line.find(" ") + 1, line.size() - 1) == "Regular")
		{
			addRegularFile(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Directory")
		{
			addDirectory(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Link")
		{
			addSymbolicLink(shell, file);
		}
		else
		{
			throw runtime_error("Filesystem is not in correct format.");
		}
	}
	Utils::recheckLinks(shell, shell.getRoot()); // recheck links because they may be linked after loading file system
	file.close();
}
Type: Regular
Name: main.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704806226
Content: #include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include <iostream>

int main(){

	try {
		Shell	shell;
		LoadFile::load(shell.getFileSystemPath(), shell); // loading file system
		while (!shell.isTerminated()) {
			try {
				Utils::printPrompt(shell); // printing prompt
				string	command;
				getline(cin, command); // getting command
				Utils::TextEngine::reset();
				shell.execute(command); // executing command
			} catch (const exception& e) {
				Utils::TextEngine::bold();
				Utils::TextEngine::red();
				cerr << e.what();
				Utils::TextEngine::reset();
				cout << endl;
			}
		}
	} catch (const exception& e) {
		Utils::TextEngine::bold();
		Utils::TextEngine::red();
		cerr << e.what();
		Utils::TextEngine::reset();
		cout << endl;
	}
}
Type: Regular
Name: RegularFile.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704806455
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

RegularFile::RegularFile(const string &name, size_t sizeBytes, time_t time, const string &data, const string &path)
	: File(name, time, path), sizeBytes(sizeBytes), data(data)
{ /*Body inintentionally left empty! */
}

RegularFile::~RegularFile()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void RegularFile::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "F ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << this->getSizeBytes() << " Bytes";
	Utils::TextEngine::reset();
	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void RegularFile::save(std::ostream &file) const
{
	file << "Type: Regular" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Content: " << getData() << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void RegularFile::cat() const
{
	for (auto it : *this) // iterator (I know it is not a good way to do this but I wanted to use iterator)
	{
		std::cout << it;
	}
	std::cout << std::endl;
}

// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void RegularFile::cd(Shell &shell) // throws exception because it is not a directory
{
	(void)shell; // unused parameter but I need it to override the virtual function
	throw std::runtime_error("cd :" + getName() + " : Not a directory");
}
Type: Regular
Name: SaveFile.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704806561
Content: #include "../includes/SaveFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include <fstream>
#include <stdexcept>

namespace
{
	// recursive function that saves subdirectories and files
	void recursive(std::ofstream &file, Directory *directory)
	{
		for (auto vfile = directory->getFiles().begin(); vfile != directory->getFiles().end(); ++vfile)
		{
			(*vfile)->save(file);
			if (dynamic_cast<Directory *>(*vfile) != nullptr)
			{
				Directory *vdFile = dynamic_cast<Directory *>(*vfile);
				recursive(file, vdFile);
			}
		}
	}
}

// Precondition: program wants to save the current state of the shell to a file
// Postcondition: the current state of the shell is saved to a file
void SaveFile::save(const std::string &path, Shell &shell)
{
	std::ofstream file(path);
	if (!file.is_open())
	{
		throw std::runtime_error("File cannot be opened!");
	}
	file << "Time: " << shell.getRoot()->getTime() << std::endl;
	for (const auto &vfile : shell.getRoot()->getFiles())
	{
		if (vfile != nullptr)
		{
			vfile->save(file);
			if (dynamic_cast<Directory *>(vfile) != nullptr) // if it is a directory then call recursive function
			{
				Directory *vdFile = dynamic_cast<Directory *>(vfile);
				recursive(file, vdFile); // recursive function
			}
		}
	}
	file.close();
}
Type: Regular
Name: Shell.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704811871
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/SaveFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/Executor.hpp"
#include <fstream>
#include <string>
#include <stdexcept>

const std::string Shell::fileSystemPath = "./os/filesystem.txt";

Shell::Shell() : isTerminating(false), prompt("/$ ")
{
	std::ifstream file(fileSystemPath);
	time_t timeT;
	string timeStr;
	if (!file.is_open())
		throw std::runtime_error("filesystem.txt not found");
	timeStr = Utils::getContent(file);
	timeT = std::stoi(timeStr);
	this->root = new Directory("/", timeT, "/");
	this->currentDirectory = this->root;
	file.close();
}

/* destructor : deletes root directory \
	deleting root directory deletes all files in it recursively. \
	because delete calls each files destructor and deletes them. */
Shell::~Shell()
{
	delete this->root;
}

void Shell::execute(string command)
{
	if (command == "")
		return;
	command = Utils::trim(command);
	vector<string> commandSplit = Utils::split(command, ' ');
	string commandName = commandSplit[0];

	if (commandName == "exit")
	{
		this->setTerminated(true);
		SaveFile::save(Shell::getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "ls")
	{
		if (commandSplit.size() == 1)
			Executor::ls(getCurrentDirectory(), *this, "");
		else if (commandSplit[1] == "-R"){
			Executor::ls(getCurrentDirectory(), *this, commandSplit[1]);
		}
		else
			throw runtime_error("ls: invalid option for cemalBolatShell -- '" + command + "'");
		return;
	}
	else if (commandName == "cat")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cat: invalid number of arguments for cemalBolatShell -- ");
		else
			Executor::cat(*this, commandSplit[1]);
		return;
	}
	else if (commandName == "rm")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("rm: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::rm(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "mkdir")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("mkdir: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::mkdir(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "cd")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cd: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::cd(*this, commandSplit[1]);
			if (getCurrentDirectory()->getName() == "/")
				this->setPrompt("/$ ");
			else
				setPrompt(getCurrentDirectory()->getPath() + getCurrentDirectory()->getName() + "$ ");
			return;
		}
	}
	else if (commandName == "cp")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("cp: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("cp: invalid number of arguments for cemalBolatShell -- ");
		else if (commandSplit[1] == "." || commandSplit[1] == ".." || commandSplit[1] == "/")
			throw runtime_error("cp: cannot copy to " + commandSplit[1] + ": file exists");
		Executor::cp(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "link")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("link: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("link: invalid number of arguments for cemalBolatShell -- ");
		Executor::link(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else
		throw invalid_argument("cemalBolatShell: " + commandName + ": command not found");
}
Type: Regular
Name: SymbolicLink.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704806816
Content: #include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

SymbolicLink::SymbolicLink(const string &name, const string &path, time_t time, File *link, const string &linkedName, const string &linkPath)
	: File(name, time, path), link(link), linkedName(linkedName), linkPath(linkPath)
{ /*Body inintentionally left empty! */
}

SymbolicLink::~SymbolicLink()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void SymbolicLink::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::red();
	os << "L ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << "2 Bytes ";
	Utils::TextEngine::reset();
	Utils::TextEngine::yellow();
	Utils::TextEngine::bold();
	os << this->getName() << " -> " << this->getLinkedPath() + this->getLinkedName();
	Utils::TextEngine::reset();

	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void SymbolicLink::save(std::ostream &file) const
{
	file << "Type: Link" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Link: " << linkPath << std::endl;
	file << "LinkedName: " << linkedName << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void SymbolicLink::cat() const
{
	if (link == nullptr)
	{
		throw std::runtime_error("cat :" + getName() + " : No such file or directory");
	}
	link->cat(); // if link is symbolic link, it will call this function again
}


// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void SymbolicLink::cd(Shell &shell)
{
	if (link == nullptr)
	{
		throw std::runtime_error("cd :" + getName() + " : No such file or directory");
	}
	link->cd(shell); // if link is symbolic link, it will call this function again

Type: Regular
Name: Template.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704801868
Content: #include "../includes/Utils.hpp"
#include "../includes/Directory.hpp"
#include <memory>

template <typename T>
T	*findTraverse(Directory *directory, const vector<string> &path)
{
	for (auto file : *directory){
		if (file->getName() == path[0])
		{
			if (path.size() == 1)
			{
				if (dynamic_cast<T *>(file))
					return dynamic_cast<T *>(file);
			}
			else
			{
				return findTraverse<T>(dynamic_cast<Directory *>(file), vector<string>(path.begin() + 1, path.end()));
			}
		}
	}
	return nullptr;
}

template <>
Directory	*File::find<Directory>(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	if (paths.size() == 0)
	{
		return shell.getRoot();
	}
	return (findTraverse<Directory>(shell.getRoot(), paths));
}

template <typename T>
T	*File::find(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	return (findTraverse<T>(shell.getRoot(), paths));

Type: Regular
Name: TextEngine.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704299052
Content: #include "../includes/TextEngine.hpp"
#include <iostream>
using namespace std;


namespace Utils {
	// namespace : TextEngine is for text coloring in terminal
	namespace TextEngine {
		void	yellow() { cout << ANSI_FG_YELLOW; }
		void	red() { cout << ANSI_FG_RED; }
		void	green() { cout << ANSI_FG_GREEN; }
		void	blue() { cout << ANSI_FG_BLUE; }
		void	reset() {cout << ANSI_RESET; }
		void	bold() { cout << ANSI_BOLD; }
		void	underline() { cout << ANSI_UNDERLINE;}
		void	blink() { cout << ANSI_BLINK;}
		void	black() { cout << ANSI_FG_BLACK; }
		void	magenta() { cout << ANSI_FG_MAGENTA; }
		void	cyan() { cout << ANSI_FG_CYAN; }
		void	white() { cout << ANSI_FG_WHITE; }
		void	redBackground() { cout << ANSI_BG_RED; }
		void	greenBackground() { cout << ANSI_BG_GREEN; }
		void	blueBackground() { cout << ANSI_BG_BLUE; }
		void	yellowBackground() { cout << ANSI_BG_YELLOW; }
		void	blackBackground() { cout << ANSI_BG_BLACK; }
		void	magentaBackground() { cout << ANSI_BG_MAGENTA; }
		void	cyanBackground() { cout << ANSI_BG_CYAN; }
		void	whiteBackground() { cout << ANSI_BG_WHITE; }
		void	resetBackground() { cout << "\033[49m"; }
		void	resetForeground() { cout << "\033[39m"; }
		void	resetAll() { cout << "\033[0m"; }
		void	orange() { cout << "\033[38;5;208m"; }
	}

Type: Regular
Name: Utils.cpp
Path: /gtu/cse/cse101/hw_notes/
Time: 1704806924
Content: #include "../includes/Utils.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include <iomanip>
#include <vector>
#include <sstream>
#include <sys/stat.h>
#include <stdexcept>

using namespace std;

namespace
{
	// Precondition: month is between 1 and 12
	// Postcondition: returns the string of month
	string convertMonth(int month)
	{
		switch (month)
		{
		case 1: return "Jan";
		case 2: return "Feb";
		case 3: return "Mar";
		case 4: return "Apr";
		case 5: return "May";
		case 6: return "Jun";
		case 7: return "Jul";
		case 8: return "Aug";
		case 9: return "Sep";
		case 10: return "Oct";
		case 11: return "Nov";
		default: return "Dec";
		}
	}
}

namespace Utils
{
	// Precondition: str is a string
	// Postcondition: returns the vector of splitted string by delim
	vector<string> split(const string &str, char delim)
	{
		std::vector<std::string> elems;
		std::stringstream ss(str);
		std::string item;
		while (std::getline(ss, item, delim))
		{
			if (!item.empty())
				elems.push_back(item);
		}
		return elems;
	}
	// Precondition: str is a string
	// Postcondition: returns the trimmed string
	string trim(const std::string &str)
	{
		size_t first = str.find_first_not_of(" \t\r");
		size_t last = str.find_last_not_of(" \t\r");

		if (first == std::string::npos || last == std::string::npos)
			return "";

		return str.substr(first, last - first + 1);
	}
	// Precondition : file is a ifstream
	// Postcondition: returns the content of file (without spaces)
	string getContent(std::ifstream &file)
	{
		string content;
		getline(file, content);
		content = trim(content);
		if (content.empty())
			throw runtime_error("File content is not configrated!");
		return content.substr(content.find(" ") + 1, content.size() - 1);
	}
	// Precondition: timeinfo is a struct tm
	// Postcondition: prints the timeinfo to os
	ostream &printTime(ostream &os, struct tm *timeinfo)
	{
		int day = timeinfo->tm_mday;
		int month = timeinfo->tm_mon + 1;
		int hour = timeinfo->tm_hour;
		int minute = timeinfo->tm_min;

		os << std::right << std::setw(3) << std::setfill('0') << convertMonth(month) << " "
		   << std::right << std::setw(2) << std::setfill('0') << day << " "
		   << std::right << std::setw(2) << std::setfill('0') << hour << ":"
		   << std::right << std::setw(2) << std::setfill('0') << minute << " ";
		return os;
	}
	// Precondition: file is a ifstream
	// Postcondition: returns the data of file
	string getData(std::ifstream &file)
	{
		string data;
		string line;
		getline(file, line);
		data = line.substr(line.find(" ") + 1, line.size() - 1);
		if (data[data.size() - 1] == static_cast<char>(3))
		{
			return data;
		}
		data += "\n";
		while (getline(file, line))
		{
			trim(line);
			data += line;
			if (!line.empty() && line[line.size() - 1] == static_cast<char>(3))
			{
				break;
			}
			data += "\n";
		}
		line += static_cast<char>(3);
		return data;
	}
	// Precondition: path is a string
	// Postcondition: returns the absolute path of path
	string relPathToAbsPath(const Shell &shell, const std::string &path)
	{
		string relPathToAbsPath;
		vector<string> relPathToAbsPathSplit;
		vector<string> relPathToAbsPathSplitTmp;
		if (path[0] == '/')
			relPathToAbsPathSplit = Utils::split(path, '/');
		else
		{
			relPathToAbsPathSplit = Utils::split(shell.getCurrentDirectory()->getOwnFilesPath() + "/" + path, '/');
		}
		if (relPathToAbsPathSplit.size() == 0)
			return "/";
		for (auto &path : relPathToAbsPathSplit)
		{
			// std::cout << path << std::endl;
			if (path == ".")
				continue;
			else if (path == "..")
			{
				if (relPathToAbsPathSplitTmp.size() > 0)
					relPathToAbsPathSplitTmp.pop_back();
			}
			else
				relPathToAbsPathSplitTmp.push_back(path);
		}
		relPathToAbsPath = "";
		for (auto &path : relPathToAbsPathSplitTmp)
		{
			relPathToAbsPath += "/" + path;
		}
		if (relPathToAbsPath == "")
			relPathToAbsPath = "/";
		return relPathToAbsPath;
	}

	string getParentPathOfAbsPath(const string &absPath)
	{
		size_t found = absPath.find_last_of('/');
		if (found != std::string::npos)
		{
			if (found == 0)
				return "/";
			return absPath.substr(0, found);
		}
		return "/";
	}
}

namespace Utils
{
	// Precondition: directory is a Directory
	// Postcondition: returns the size of directory recursively
	// Note: size of directory is the sum of size of its files and its subdirectories recursively + 15 is the size of saving system information
	size_t getProgramSize(const Shell &Shell)
	{
		struct stat st;
		stat(Shell.getFileSystemPath().c_str(), &st);
		return st.st_size;
	}
}

namespace Utils
{
	// Precondition: shell is a Shell
	// Postcondition: rechecks the links of shell recursively because of the possibility of deleting linked files or creating new files for linking to them
	void recheckLinks(Shell &shell, Directory *directory)
	{
		for (auto it = directory->getFiles().begin(); it != directory->getFiles().end(); ++it)
		{
			if (dynamic_cast<SymbolicLink *>(*it) != nullptr)
			{ // if file is a symbolic link
				SymbolicLink *link = dynamic_cast<SymbolicLink *>(*it);
				File *linkFile = File::find<File>(shell, link->getLinkedPath() + "/" + link->getLinkedName());
				link->setLink(linkFile);
			}
			else if (dynamic_cast<Directory *>(*it) != nullptr)
			{ // if file is a directory then recursive call
				Directory *dir = dynamic_cast<Directory *>(*it);
				recheckLinks(shell, dir);
			}
		}
	}
}

namespace Utils {
	// prints the prompt properly
	void printPrompt(const Shell &shell) {
		Utils::TextEngine::green();
		Utils::TextEngine::bold();
		cout << "cemalBolat@C++0S:";
		Utils::TextEngine::reset();
		Utils::TextEngine::bold();
		Utils::TextEngine::blue();
		cout << shell.getPrompt();
		Utils::TextEngine::magenta();
	}
}
Type: Directory
Name: cse102
Path: /gtu/cse/
Time: 1704812948
Type: Directory
Name: hw_notes
Path: /gtu/cse/cse102/
Time: 1704299052
Type: Regular
Name: Directory.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704802991
Content: #include "../includes/Directory.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/Shell.hpp"
#include <ctime>		// std::localtime
#include <sstream>		// std::stringstream
#include <iomanip>		// std::setw
#include <stdexcept>	// std::runtime_error

// constructor for root directory
Directory::Directory(const string &name, time_t time, const string &path)
	: File(name, time, path), ownFilesPath("/"), parentDirectory(nullptr)
{
	files = vector<File *>();
}

// constructor for other directories
Directory::Directory(const string &name, time_t time, const string &path, Directory *parentDirectory)
	: File(name, time, path), ownFilesPath(path + name + "/"), parentDirectory(parentDirectory)
{
	files = vector<File *>();
}

// destructor : delete calls each files destructor and deletes them.
// then deletes itself.
Directory::~Directory()
{
	for (auto file : this->files)
		delete file;
}

// Preconditions: User wants to add a file to this directory.
// Postconditions: Adds file to files vector. <push_back>
void Directory::addFile(File *file)
{
	this->files.push_back(file);
}

// Preconditions: User wants to print the information about this directory with using ls or something.
// Postconditions: Prints the information about this directory. <colorful way>
void Directory::print(std::ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "D ";
	Utils::TextEngine::reset();
	Utils::TextEngine::bold();
	Utils::TextEngine::cyan();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();

	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::resetAll();
	os << std::endl;
}

// Preconditions : Progaram wants to save this directory to filesystem.txt file.
// Postconditions : Saves this directory to filesystem.txt file.
void Directory::save(std::ostream &file) const
{
	file << "Type: Directory" << std::endl;
	file << "Name: " << this->getName() << std::endl;
	file << "Path: " << this->getPath() << std::endl;
	file << "Time: " << this->getTime() << std::endl;
}

// Preconditions: User wants to cat this directory.
// Postconditions: Throws runtime_error.
void Directory::cat() const
{
	throw std::runtime_error("cat: " + this->getName() + ": Is a directory");
}

// Preconditions: User wants to remove a specific named file from this directory.
// Postconditions: Removes file from files vector and deletes it <erase>
void Directory::removeFile(const string &name)
{
	for (auto it = this->files.begin(); it != this->files.end(); ++it)
	{
		if ((*it)->getName() == name)
		{
			delete *it;
			this->files.erase(it);
			return;
		}
	}
}

// Preconditions: User wants to change current directory to this directory.
// Postconditions: Changes current directory to this directory.
void Directory::cd(Shell &shell)
{
	shell.setCurrentDirectory(this);
}
Type: Regular
Name: Executor.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704810937
Content: #include "../includes/Executor.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/File.hpp"
#include "../includes/Directory.hpp"
#include "./Template.cpp"
#include <ctime>
#include <sys/stat.h>
#include <fstream>
#include <dirent.h>
#include <sys/types.h>
#include <fcntl.h>
#include <iomanip>
#include <cstring>
#include <stdexcept>

//****************************************  LS  ****************************************//
namespace
{

	// Getting absolute path of a file only by its name while listing files
	string absPathToRelPath(const Shell &shell, const string &path)
	{
		return path.substr(shell.getCurrentDirectory()->getOwnFilesPath().size(), path.size() - 1);
	}
	// lisiting only current directory '.'
	void listOnlyCurrentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << "."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
	// listing parent directory '..'
	void listParentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getParentDirectory()->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << ".."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
}

namespace
{
	// returns max name length of files in directory to align
	size_t getMaxNameLength(const Directory *directory)
	{
		size_t maxNameLength = 2; // for '.' and '..'
		for (auto file : *directory)
		{
			if (file->getName().length() > maxNameLength)
				maxNameLength = file->getName().length();
		}
		return maxNameLength;
	}
}

namespace Executor
{
	// Precondition: User wants to execute ls command
	// Postcondition: ls command is executed
	// @param directory: current directory
	// @param option: option for ls command
	/*
		ls command is used to list files and directories in current directory.
		ls command's '-R' option has a special print format. Firstly it prints current directory's files and directories.
		Then it prints subdirectories' files and directories recursively.
	*/
	void ls(const Directory *directory, const Shell &Shell, const string &option)
	{
		size_t	maxNameLength = getMaxNameLength(directory); // for align
		listOnlyCurrentDirectory(cout, directory, maxNameLength); // listing '.' is a must for ls command
		if (directory != Shell.getRoot()) // listing '..' is a must except root directory
			listParentDirectory(cout, directory, maxNameLength);
		for (auto file : *directory)
			file->print(cout, maxNameLength);
		if (option == "-R")
		{
			for (auto file : *directory)
			{
				if (dynamic_cast<Directory *>(file))
				{
					Directory *directory = dynamic_cast<Directory *>(file);
					cout << "\n";
					Utils::TextEngine::orange();
					cout << "./" << absPathToRelPath(Shell, directory->getOwnFilesPath()) << ":";
					Utils::TextEngine::reset();
					cout << endl;
					ls(directory, Shell, option);
				}
			}
		}
	}
}

//****************************************  LS OVER ****************************************//

//****************************************  CAT  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute cat command
	// Postcondition: cat command is executed
	void cat(const Shell &shell, const string &fileName)
	{
		File	*filePtr = nullptr;

		if (fileName.empty())
			throw runtime_error("cat: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cat: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName); // get absolute path of file
			if (absPath == "/")
				throw runtime_error("cat: " + fileName + ": Is a directory"); // root directory cannot be printed
			filePtr = File::find<File>(shell, absPath);
			if (filePtr == nullptr)
				throw invalid_argument("cat: " + fileName + ": No such file or directory");
			filePtr->cat(); // <polymorphism>
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  CAT OVER ****************************************//

//****************************************  RM  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute rm command
	// Postcondition: rm command is executed
	void	rm(const Shell &shell, const string &fileName)
	{
		File		*filePtr = nullptr;
		Directory	*parentDirectory = nullptr;

		if (fileName.empty())
			throw runtime_error("rm: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("rm: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("rm: cannot remove '" + fileName + "': Is a directory"); // root directory cannot be deleted
			filePtr = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absPath));
			if (filePtr == nullptr)
				throw invalid_argument("rm: cannot remove '" + fileName + "': No such file or directory");
			if (dynamic_cast<Directory *>(filePtr))
				throw invalid_argument("rm: cannot remove '" + fileName + "': Is a directory"); // directory cannot be deleted as you said in pdf
			parentDirectory->removeFile(filePtr->getName()); // remove file from parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  RM OVER ****************************************//
//****************************************  MKDIR  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute mkdir command
	// Postcondition: mkdir command is executed
	// @brief : '' Makes or removes a directory '' as pdf says
	void mkdir(const Shell &shell, const string &fileName)
	{
		File		*directory = nullptr;
		Directory	*parentDirectory = nullptr;
		if (fileName.empty())
			throw runtime_error("mkdir: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists"); // root directory cannot be created and deleted
			string pPath = Utils::getParentPathOfAbsPath(absPath);
			if (pPath == "/")
				pPath = ""; // if parent directory is root directory, parent directory's path is empty
			directory = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, pPath);
			if (directory != nullptr) // delete if existent file is directory and throw exception if not
			{
				if (dynamic_cast<Directory *>(directory)) // if file is directory
				{
					parentDirectory->removeFile(absPath.substr(absPath.find_last_of('/') + 1)); // remove directory from parent directory
					parentDirectory->setTime(time(nullptr));
				}
				else
					throw invalid_argument("mkdir: cannot create directory '" + fileName + "': File exists"); // if file is not directory throw exception
				return;
			}
			else if (parentDirectory == nullptr) // if parent directory does not exist throw exception <for root directory parent directory manipulalated as root too at find function>
				throw invalid_argument("mkdir: cannot create directory '" + fileName + "': No such file or directory");
			string name = absPath.substr(absPath.find_last_of('/') + 1);
			if (parentDirectory == shell.getRoot()) // if parent directory is root directory
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath(), parentDirectory);
			else
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath() + parentDirectory->getName() + "/", parentDirectory);
			parentDirectory->addFile(directory); // add directory to parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}
//****************************************  MKDIR OVER ****************************************//
//****************************************  CD  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute cd command
	// Postcondition: cd command is executed
	// @brief : '' Changes the current directory '' as pdf says
	// @brief '.' and '..' are special cases for cd command and empty string is special case for cd command
	// @brief if directory is not existent throw exception
	void	cd(Shell &shell, const string &directoryName)
	{
		File	*directory = nullptr;
		if (directoryName.empty()) // if directory name is empty set current directory to root directory
			shell.setCurrentDirectory(shell.getRoot());
		else if (directoryName == ".") // if directory name is '.' do nothing
			return;
		else if (directoryName == "..") // if directory name is '..' set current directory to parent directory
		{
			if (shell.getCurrentDirectory() == shell.getRoot()) // if current directory is root directory do nothing
				return;
			shell.setCurrentDirectory(shell.getCurrentDirectory()->getParentDirectory());
		}
		else
		{
			try
			{
				string pPath = Utils::relPathToAbsPath(shell, directoryName);
				if (pPath == "/")
				{
					shell.setCurrentDirectory(shell.getRoot());
					return;
				}
				directory = File::find<File>(shell, pPath);
				if (directory == nullptr)
					throw invalid_argument("cd: " + directoryName + ": No such file or directory");
				directory->cd(shell); // <polymorphism>
			}
			catch (const invalid_argument &e)
			{
				throw e;
			}
		}
	}
}

// ****************************************  CD OVER ****************************************//
// ****************************************  CP  ****************************************//

namespace
{
	// Precondition: User wants to execute cp command and source is a regular file
	// Postcondition: cp command is executed and source is copied to destination
	// @brief : '' Copies file and directory from our original os '' as pdf says
	RegularFile	*copyRegularFile(const string &source, const string &fileName, const struct stat &sourceStat, const string &path)
	{
		ifstream	sourceFile(source);
		RegularFile	*regularFile;
		string		data, line;
		if (!sourceFile.is_open())
			throw runtime_error("cp: source file '" + source + "' does not exist");
		while (getline(sourceFile, line)) // read file line by line
		{
			data += line + "\n";
		}
		data = data.substr(0, data.size() - 2);
		data += static_cast<char>(3); // end of text character
		sourceFile.close();
		regularFile = new RegularFile(fileName, data.size(), sourceStat.st_mtime, data, path); // create regular file
		return regularFile;
	}
}

namespace
{
	// Precondition: User wants to execute cp command and source is a directory
	// Postcondition: cp command is executed and source is copied to destination
	Directory *copyDirectory(const string &source, const string &fileName, const Shell &shell, const struct stat &sourceStat, const string &path, Directory *parentDirectory)
	{
		Directory	*directory; // directory to be copied

		DIR *copiedDir = opendir(source.c_str()); // open directory
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		struct dirent *entry; // entry of directory
		directory = new Directory(fileName, sourceStat.st_mtime, path, parentDirectory); // create directory
		while ((entry = readdir(copiedDir)) != nullptr) // read the directory until end
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) // ignore '.' and '..'
			{
				std::string entryPath = source + "/" + entry->d_name; // get entry's path

				struct stat entryStat; // entry's stat
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'"); // if stat cannot be accessed throw exception and exit
				}
				if (S_ISREG(entryStat.st_mode))
				{
					// Copy regular file
					RegularFile *regularFile = copyRegularFile(entryPath, entry->d_name, entryStat, directory->getOwnFilesPath());
					directory->addFile(regularFile); // add regular file to directory
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					// Recursively copy subdirectories
					Directory *subDirectory = copyDirectory(entryPath, entry->d_name, shell, entryStat, directory->getOwnFilesPath(), directory);
					directory->addFile(subDirectory); // add subdirectory to directory
				}
			}
		}
		closedir(copiedDir); // close directory
		return (directory);
	}
}

namespace
{
	// Precondition: User wants to execute cp command so program gets the size of directory
	// Postcondition: Returns the size of directory
	size_t getDirectorySize(const struct stat &sourcestat, const string &source)
	{
		DIR *copiedDir = opendir(source.c_str());
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		(void)sourcestat; // unused
		struct dirent *entry;
		size_t size = 0;
		while ((entry = readdir(copiedDir)) != nullptr)
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0)
			{
				std::string entryPath = source + "/" + entry->d_name;

				struct stat entryStat;
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'");
				}

				if (S_ISREG(entryStat.st_mode))
				{
					size += entryStat.st_size;
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					size += getDirectorySize(entryStat, entryPath); // recursively get subdirectories' size
				}
			}
		}
		closedir(copiedDir);
		return (size);
	}
}

namespace
{
	// Precondition: User wants to execute cp command
	// Postcondition: cp command is executed and source is copied to destination
	void onlyAddToDirectory(const Shell &shell, const string &source, const string &fileName, const struct stat &sourceStat)
	{

		if (S_ISREG(sourceStat.st_mode))
		{
			RegularFile *regularFile = copyRegularFile(source, fileName, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath());
			shell.getCurrentDirectory()->addFile(regularFile);
			shell.getCurrentDirectory()->setTime(time(nullptr));
		}
		else if (S_ISDIR(sourceStat.st_mode))
		{
			Directory *directory = copyDirectory(source, fileName, shell, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath(), shell.getCurrentDirectory());
			shell.getCurrentDirectory()->addFile(directory);
		}
		shell.getCurrentDirectory()->setTime(time(nullptr));
	}
}

namespace Executor
{
	// Precondition: User wants to execute cp command
	// Postcondition: program executes cp command
	void cp(const Shell &shell, const string &source, const string &fileName)
	{

		struct stat	sourceStat;
		File		*file = nullptr;

		if (source.empty() || fileName.empty())
			throw runtime_error("cp: missing operand");
		if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists");
		if (stat(source.c_str(), &sourceStat) != 0)
		{
			throw std::runtime_error("cp: source file '" + source + "' does not exist"); // if stat cannot be accessed throw exception and exit
		}
		file = File::find<File>(shell, shell.getCurrentDirectory()->getOwnFilesPath() + fileName);
		if (file != nullptr)
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists"); // if file exists throw exception
		if (S_ISREG(sourceStat.st_mode) && sourceStat.st_size + Utils::getProgramSize(shell) > shell.getOsSize()) // size of file + size of program > size of os
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		if (S_ISDIR(sourceStat.st_mode) && getDirectorySize(sourceStat, source) + Utils::getProgramSize(shell) > shell.getOsSize())
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		onlyAddToDirectory(shell, source, fileName, sourceStat); // add file to current directory
	}
}

// ****************************************  CP OVER ****************************************//
// ****************************************  LINK  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute link command
	// Postcondition: program executes link command
	void link(const Shell &shell, const string &source, const string &dest)
	{
		Directory		*destDirectory = nullptr;
		Directory		*sourceDirectory = nullptr;
		File			*sourceFile = nullptr;
		File			*destFile = nullptr;
		SymbolicLink	*symbolicLink = nullptr; // symbolic link to be created

		string absSourcePath = Utils::relPathToAbsPath(shell, source);
		string absDestPath = Utils::relPathToAbsPath(shell, dest);
		if (dest.empty() || source.empty())
			throw runtime_error("link: missing operand");
		else if (dest == "." || dest == ".." || dest == "/")
			throw runtime_error("link: cannot create link '" + dest + "': File exists");
		try
		{
			destFile = File::find<File>(shell, absDestPath);
			destDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absDestPath));
			if (destDirectory == nullptr) // if destination directory does not exist throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': No such file or directory");
			if (destFile != nullptr) // if destination file exists throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': File exists");
			sourceFile = File::find<File>(shell, absSourcePath);
			sourceDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absSourcePath));
			if (sourceDirectory == nullptr){
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), Utils::getParentPathOfAbsPath(absSourcePath) + "/");
			}
			else {
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), sourceDirectory->getOwnFilesPath());
			}
			destDirectory->addFile(symbolicLink); // add symbolic link to destination directory
			destDirectory->setTime(time(nullptr)); // set destination directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

// ****************************************  LINK OVER ****************************************//
Type: Regular
Name: File.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704805811
Content: #include "../includes/File.hpp"

File::File(const string &name, time_t time, const string& path)
	: name(name) , path(path) ,time(time)
{/*Body inintentionally left empty! */}


File::~File()
{/*Body inintentionally left empty! */}
Type: Regular
Name: LoadFile.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704806200
Content: #include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include <fstream>
#include <string>
#include <ctime>
#include <sstream>
#include <stdexcept>

using namespace std;

// Precondition: program wants to load regular file
// Postcondition: regular file is loaded
void LoadFile::addRegularFile(Shell &shell, ifstream &file)
{
	string name, path, time, data;
	Directory *directory = shell.getRoot();
	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	data = Utils::getData(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		directory = shell.getRoot();
		directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
		return;
	}
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem may not be configrated ! ");
	directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
}

// Precondition: program wants to load directory
// Postcondition: directory is loaded
void LoadFile::addDirectory(Shell &shell, ifstream &file)
{
	string name, path, time;
	Directory *parentDirectory;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		parentDirectory = shell.getRoot();
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
	else
	{
		parentDirectory = File::find<Directory>(shell, path);
		if (parentDirectory == nullptr)
			throw runtime_error("Directory coould not be found.");
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
}

// Precondition: program wants to load symbolic link
// Postcondition: symbolic link is loaded
void LoadFile::addSymbolicLink(Shell &shell, ifstream &file)
{
	string name, path, time, linkPath, linkerName;
	File *link = nullptr;
	Directory *directory = nullptr;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	linkPath = Utils::getContent(file);
	linkerName = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	link = File::find<File>(shell, linkPath + linkerName);
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem file is broken"); // not configrated
	directory->addFile(new SymbolicLink(name, path, time_t_time, link, linkerName, linkPath));
}

// Precondition: program wants to load file system
// Postcondition: file system is loaded
void LoadFile::load(const std::string &path, Shell &shell)
{
	ifstream file(path);

	if (!file.is_open())
		throw runtime_error("File could not be opened.");
	string lineTmp;			// to ignore first line for roots time
	getline(file, lineTmp); // ignore first line
	while (!file.eof())
	{
		string line;
		getline(file, line);
		line = Utils::trim(line);
		if (line.empty())
			continue;
		if (line.substr(line.find(" ") + 1, line.size() - 1) == "Regular")
		{
			addRegularFile(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Directory")
		{
			addDirectory(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Link")
		{
			addSymbolicLink(shell, file);
		}
		else
		{
			throw runtime_error("Filesystem is not in correct format.");
		}
	}
	Utils::recheckLinks(shell, shell.getRoot()); // recheck links because they may be linked after loading file system
	file.close();
}
Type: Regular
Name: main.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704806226
Content: #include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include <iostream>

int main(){

	try {
		Shell	shell;
		LoadFile::load(shell.getFileSystemPath(), shell); // loading file system
		while (!shell.isTerminated()) {
			try {
				Utils::printPrompt(shell); // printing prompt
				string	command;
				getline(cin, command); // getting command
				Utils::TextEngine::reset();
				shell.execute(command); // executing command
			} catch (const exception& e) {
				Utils::TextEngine::bold();
				Utils::TextEngine::red();
				cerr << e.what();
				Utils::TextEngine::reset();
				cout << endl;
			}
		}
	} catch (const exception& e) {
		Utils::TextEngine::bold();
		Utils::TextEngine::red();
		cerr << e.what();
		Utils::TextEngine::reset();
		cout << endl;
	}
}
Type: Regular
Name: RegularFile.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704806455
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

RegularFile::RegularFile(const string &name, size_t sizeBytes, time_t time, const string &data, const string &path)
	: File(name, time, path), sizeBytes(sizeBytes), data(data)
{ /*Body inintentionally left empty! */
}

RegularFile::~RegularFile()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void RegularFile::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "F ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << this->getSizeBytes() << " Bytes";
	Utils::TextEngine::reset();
	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void RegularFile::save(std::ostream &file) const
{
	file << "Type: Regular" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Content: " << getData() << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void RegularFile::cat() const
{
	for (auto it : *this) // iterator (I know it is not a good way to do this but I wanted to use iterator)
	{
		std::cout << it;
	}
	std::cout << std::endl;
}

// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void RegularFile::cd(Shell &shell) // throws exception because it is not a directory
{
	(void)shell; // unused parameter but I need it to override the virtual function
	throw std::runtime_error("cd :" + getName() + " : Not a directory");
}
Type: Regular
Name: SaveFile.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704806561
Content: #include "../includes/SaveFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include <fstream>
#include <stdexcept>

namespace
{
	// recursive function that saves subdirectories and files
	void recursive(std::ofstream &file, Directory *directory)
	{
		for (auto vfile = directory->getFiles().begin(); vfile != directory->getFiles().end(); ++vfile)
		{
			(*vfile)->save(file);
			if (dynamic_cast<Directory *>(*vfile) != nullptr)
			{
				Directory *vdFile = dynamic_cast<Directory *>(*vfile);
				recursive(file, vdFile);
			}
		}
	}
}

// Precondition: program wants to save the current state of the shell to a file
// Postcondition: the current state of the shell is saved to a file
void SaveFile::save(const std::string &path, Shell &shell)
{
	std::ofstream file(path);
	if (!file.is_open())
	{
		throw std::runtime_error("File cannot be opened!");
	}
	file << "Time: " << shell.getRoot()->getTime() << std::endl;
	for (const auto &vfile : shell.getRoot()->getFiles())
	{
		if (vfile != nullptr)
		{
			vfile->save(file);
			if (dynamic_cast<Directory *>(vfile) != nullptr) // if it is a directory then call recursive function
			{
				Directory *vdFile = dynamic_cast<Directory *>(vfile);
				recursive(file, vdFile); // recursive function
			}
		}
	}
	file.close();
}
Type: Regular
Name: Shell.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704811871
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/SaveFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/Executor.hpp"
#include <fstream>
#include <string>
#include <stdexcept>

const std::string Shell::fileSystemPath = "./os/filesystem.txt";

Shell::Shell() : isTerminating(false), prompt("/$ ")
{
	std::ifstream file(fileSystemPath);
	time_t timeT;
	string timeStr;
	if (!file.is_open())
		throw std::runtime_error("filesystem.txt not found");
	timeStr = Utils::getContent(file);
	timeT = std::stoi(timeStr);
	this->root = new Directory("/", timeT, "/");
	this->currentDirectory = this->root;
	file.close();
}

/* destructor : deletes root directory \
	deleting root directory deletes all files in it recursively. \
	because delete calls each files destructor and deletes them. */
Shell::~Shell()
{
	delete this->root;
}

void Shell::execute(string command)
{
	if (command == "")
		return;
	command = Utils::trim(command);
	vector<string> commandSplit = Utils::split(command, ' ');
	string commandName = commandSplit[0];

	if (commandName == "exit")
	{
		this->setTerminated(true);
		SaveFile::save(Shell::getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "ls")
	{
		if (commandSplit.size() == 1)
			Executor::ls(getCurrentDirectory(), *this, "");
		else if (commandSplit[1] == "-R"){
			Executor::ls(getCurrentDirectory(), *this, commandSplit[1]);
		}
		else
			throw runtime_error("ls: invalid option for cemalBolatShell -- '" + command + "'");
		return;
	}
	else if (commandName == "cat")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cat: invalid number of arguments for cemalBolatShell -- ");
		else
			Executor::cat(*this, commandSplit[1]);
		return;
	}
	else if (commandName == "rm")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("rm: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::rm(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "mkdir")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("mkdir: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::mkdir(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "cd")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cd: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::cd(*this, commandSplit[1]);
			if (getCurrentDirectory()->getName() == "/")
				this->setPrompt("/$ ");
			else
				setPrompt(getCurrentDirectory()->getPath() + getCurrentDirectory()->getName() + "$ ");
			return;
		}
	}
	else if (commandName == "cp")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("cp: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("cp: invalid number of arguments for cemalBolatShell -- ");
		else if (commandSplit[1] == "." || commandSplit[1] == ".." || commandSplit[1] == "/")
			throw runtime_error("cp: cannot copy to " + commandSplit[1] + ": file exists");
		Executor::cp(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "link")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("link: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("link: invalid number of arguments for cemalBolatShell -- ");
		Executor::link(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else
		throw invalid_argument("cemalBolatShell: " + commandName + ": command not found");
}
Type: Regular
Name: SymbolicLink.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704806816
Content: #include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

SymbolicLink::SymbolicLink(const string &name, const string &path, time_t time, File *link, const string &linkedName, const string &linkPath)
	: File(name, time, path), link(link), linkedName(linkedName), linkPath(linkPath)
{ /*Body inintentionally left empty! */
}

SymbolicLink::~SymbolicLink()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void SymbolicLink::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::red();
	os << "L ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << "2 Bytes ";
	Utils::TextEngine::reset();
	Utils::TextEngine::yellow();
	Utils::TextEngine::bold();
	os << this->getName() << " -> " << this->getLinkedPath() + this->getLinkedName();
	Utils::TextEngine::reset();

	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void SymbolicLink::save(std::ostream &file) const
{
	file << "Type: Link" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Link: " << linkPath << std::endl;
	file << "LinkedName: " << linkedName << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void SymbolicLink::cat() const
{
	if (link == nullptr)
	{
		throw std::runtime_error("cat :" + getName() + " : No such file or directory");
	}
	link->cat(); // if link is symbolic link, it will call this function again
}


// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void SymbolicLink::cd(Shell &shell)
{
	if (link == nullptr)
	{
		throw std::runtime_error("cd :" + getName() + " : No such file or directory");
	}
	link->cd(shell); // if link is symbolic link, it will call this function again

Type: Regular
Name: Template.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704801868
Content: #include "../includes/Utils.hpp"
#include "../includes/Directory.hpp"
#include <memory>

template <typename T>
T	*findTraverse(Directory *directory, const vector<string> &path)
{
	for (auto file : *directory){
		if (file->getName() == path[0])
		{
			if (path.size() == 1)
			{
				if (dynamic_cast<T *>(file))
					return dynamic_cast<T *>(file);
			}
			else
			{
				return findTraverse<T>(dynamic_cast<Directory *>(file), vector<string>(path.begin() + 1, path.end()));
			}
		}
	}
	return nullptr;
}

template <>
Directory	*File::find<Directory>(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	if (paths.size() == 0)
	{
		return shell.getRoot();
	}
	return (findTraverse<Directory>(shell.getRoot(), paths));
}

template <typename T>
T	*File::find(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	return (findTraverse<T>(shell.getRoot(), paths));

Type: Regular
Name: TextEngine.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704299052
Content: #include "../includes/TextEngine.hpp"
#include <iostream>
using namespace std;


namespace Utils {
	// namespace : TextEngine is for text coloring in terminal
	namespace TextEngine {
		void	yellow() { cout << ANSI_FG_YELLOW; }
		void	red() { cout << ANSI_FG_RED; }
		void	green() { cout << ANSI_FG_GREEN; }
		void	blue() { cout << ANSI_FG_BLUE; }
		void	reset() {cout << ANSI_RESET; }
		void	bold() { cout << ANSI_BOLD; }
		void	underline() { cout << ANSI_UNDERLINE;}
		void	blink() { cout << ANSI_BLINK;}
		void	black() { cout << ANSI_FG_BLACK; }
		void	magenta() { cout << ANSI_FG_MAGENTA; }
		void	cyan() { cout << ANSI_FG_CYAN; }
		void	white() { cout << ANSI_FG_WHITE; }
		void	redBackground() { cout << ANSI_BG_RED; }
		void	greenBackground() { cout << ANSI_BG_GREEN; }
		void	blueBackground() { cout << ANSI_BG_BLUE; }
		void	yellowBackground() { cout << ANSI_BG_YELLOW; }
		void	blackBackground() { cout << ANSI_BG_BLACK; }
		void	magentaBackground() { cout << ANSI_BG_MAGENTA; }
		void	cyanBackground() { cout << ANSI_BG_CYAN; }
		void	whiteBackground() { cout << ANSI_BG_WHITE; }
		void	resetBackground() { cout << "\033[49m"; }
		void	resetForeground() { cout << "\033[39m"; }
		void	resetAll() { cout << "\033[0m"; }
		void	orange() { cout << "\033[38;5;208m"; }
	}

Type: Regular
Name: Utils.cpp
Path: /gtu/cse/cse102/hw_notes/
Time: 1704806924
Content: #include "../includes/Utils.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include <iomanip>
#include <vector>
#include <sstream>
#include <sys/stat.h>
#include <stdexcept>

using namespace std;

namespace
{
	// Precondition: month is between 1 and 12
	// Postcondition: returns the string of month
	string convertMonth(int month)
	{
		switch (month)
		{
		case 1: return "Jan";
		case 2: return "Feb";
		case 3: return "Mar";
		case 4: return "Apr";
		case 5: return "May";
		case 6: return "Jun";
		case 7: return "Jul";
		case 8: return "Aug";
		case 9: return "Sep";
		case 10: return "Oct";
		case 11: return "Nov";
		default: return "Dec";
		}
	}
}

namespace Utils
{
	// Precondition: str is a string
	// Postcondition: returns the vector of splitted string by delim
	vector<string> split(const string &str, char delim)
	{
		std::vector<std::string> elems;
		std::stringstream ss(str);
		std::string item;
		while (std::getline(ss, item, delim))
		{
			if (!item.empty())
				elems.push_back(item);
		}
		return elems;
	}
	// Precondition: str is a string
	// Postcondition: returns the trimmed string
	string trim(const std::string &str)
	{
		size_t first = str.find_first_not_of(" \t\r");
		size_t last = str.find_last_not_of(" \t\r");

		if (first == std::string::npos || last == std::string::npos)
			return "";

		return str.substr(first, last - first + 1);
	}
	// Precondition : file is a ifstream
	// Postcondition: returns the content of file (without spaces)
	string getContent(std::ifstream &file)
	{
		string content;
		getline(file, content);
		content = trim(content);
		if (content.empty())
			throw runtime_error("File content is not configrated!");
		return content.substr(content.find(" ") + 1, content.size() - 1);
	}
	// Precondition: timeinfo is a struct tm
	// Postcondition: prints the timeinfo to os
	ostream &printTime(ostream &os, struct tm *timeinfo)
	{
		int day = timeinfo->tm_mday;
		int month = timeinfo->tm_mon + 1;
		int hour = timeinfo->tm_hour;
		int minute = timeinfo->tm_min;

		os << std::right << std::setw(3) << std::setfill('0') << convertMonth(month) << " "
		   << std::right << std::setw(2) << std::setfill('0') << day << " "
		   << std::right << std::setw(2) << std::setfill('0') << hour << ":"
		   << std::right << std::setw(2) << std::setfill('0') << minute << " ";
		return os;
	}
	// Precondition: file is a ifstream
	// Postcondition: returns the data of file
	string getData(std::ifstream &file)
	{
		string data;
		string line;
		getline(file, line);
		data = line.substr(line.find(" ") + 1, line.size() - 1);
		if (data[data.size() - 1] == static_cast<char>(3))
		{
			return data;
		}
		data += "\n";
		while (getline(file, line))
		{
			trim(line);
			data += line;
			if (!line.empty() && line[line.size() - 1] == static_cast<char>(3))
			{
				break;
			}
			data += "\n";
		}
		line += static_cast<char>(3);
		return data;
	}
	// Precondition: path is a string
	// Postcondition: returns the absolute path of path
	string relPathToAbsPath(const Shell &shell, const std::string &path)
	{
		string relPathToAbsPath;
		vector<string> relPathToAbsPathSplit;
		vector<string> relPathToAbsPathSplitTmp;
		if (path[0] == '/')
			relPathToAbsPathSplit = Utils::split(path, '/');
		else
		{
			relPathToAbsPathSplit = Utils::split(shell.getCurrentDirectory()->getOwnFilesPath() + "/" + path, '/');
		}
		if (relPathToAbsPathSplit.size() == 0)
			return "/";
		for (auto &path : relPathToAbsPathSplit)
		{
			// std::cout << path << std::endl;
			if (path == ".")
				continue;
			else if (path == "..")
			{
				if (relPathToAbsPathSplitTmp.size() > 0)
					relPathToAbsPathSplitTmp.pop_back();
			}
			else
				relPathToAbsPathSplitTmp.push_back(path);
		}
		relPathToAbsPath = "";
		for (auto &path : relPathToAbsPathSplitTmp)
		{
			relPathToAbsPath += "/" + path;
		}
		if (relPathToAbsPath == "")
			relPathToAbsPath = "/";
		return relPathToAbsPath;
	}

	string getParentPathOfAbsPath(const string &absPath)
	{
		size_t found = absPath.find_last_of('/');
		if (found != std::string::npos)
		{
			if (found == 0)
				return "/";
			return absPath.substr(0, found);
		}
		return "/";
	}
}

namespace Utils
{
	// Precondition: directory is a Directory
	// Postcondition: returns the size of directory recursively
	// Note: size of directory is the sum of size of its files and its subdirectories recursively + 15 is the size of saving system information
	size_t getProgramSize(const Shell &Shell)
	{
		struct stat st;
		stat(Shell.getFileSystemPath().c_str(), &st);
		return st.st_size;
	}
}

namespace Utils
{
	// Precondition: shell is a Shell
	// Postcondition: rechecks the links of shell recursively because of the possibility of deleting linked files or creating new files for linking to them
	void recheckLinks(Shell &shell, Directory *directory)
	{
		for (auto it = directory->getFiles().begin(); it != directory->getFiles().end(); ++it)
		{
			if (dynamic_cast<SymbolicLink *>(*it) != nullptr)
			{ // if file is a symbolic link
				SymbolicLink *link = dynamic_cast<SymbolicLink *>(*it);
				File *linkFile = File::find<File>(shell, link->getLinkedPath() + "/" + link->getLinkedName());
				link->setLink(linkFile);
			}
			else if (dynamic_cast<Directory *>(*it) != nullptr)
			{ // if file is a directory then recursive call
				Directory *dir = dynamic_cast<Directory *>(*it);
				recheckLinks(shell, dir);
			}
		}
	}
}

namespace Utils {
	// prints the prompt properly
	void printPrompt(const Shell &shell) {
		Utils::TextEngine::green();
		Utils::TextEngine::bold();
		cout << "cemalBolat@C++0S:";
		Utils::TextEngine::reset();
		Utils::TextEngine::bold();
		Utils::TextEngine::blue();
		cout << shell.getPrompt();
		Utils::TextEngine::magenta();
	}
}
Type: Directory
Name: cse107
Path: /gtu/cse/
Time: 1704812956
Type: Directory
Name: lab_notes
Path: /gtu/cse/cse107/
Time: 1704299052
Type: Regular
Name: Directory.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704802991
Content: #include "../includes/Directory.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/Shell.hpp"
#include <ctime>		// std::localtime
#include <sstream>		// std::stringstream
#include <iomanip>		// std::setw
#include <stdexcept>	// std::runtime_error

// constructor for root directory
Directory::Directory(const string &name, time_t time, const string &path)
	: File(name, time, path), ownFilesPath("/"), parentDirectory(nullptr)
{
	files = vector<File *>();
}

// constructor for other directories
Directory::Directory(const string &name, time_t time, const string &path, Directory *parentDirectory)
	: File(name, time, path), ownFilesPath(path + name + "/"), parentDirectory(parentDirectory)
{
	files = vector<File *>();
}

// destructor : delete calls each files destructor and deletes them.
// then deletes itself.
Directory::~Directory()
{
	for (auto file : this->files)
		delete file;
}

// Preconditions: User wants to add a file to this directory.
// Postconditions: Adds file to files vector. <push_back>
void Directory::addFile(File *file)
{
	this->files.push_back(file);
}

// Preconditions: User wants to print the information about this directory with using ls or something.
// Postconditions: Prints the information about this directory. <colorful way>
void Directory::print(std::ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "D ";
	Utils::TextEngine::reset();
	Utils::TextEngine::bold();
	Utils::TextEngine::cyan();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();

	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::resetAll();
	os << std::endl;
}

// Preconditions : Progaram wants to save this directory to filesystem.txt file.
// Postconditions : Saves this directory to filesystem.txt file.
void Directory::save(std::ostream &file) const
{
	file << "Type: Directory" << std::endl;
	file << "Name: " << this->getName() << std::endl;
	file << "Path: " << this->getPath() << std::endl;
	file << "Time: " << this->getTime() << std::endl;
}

// Preconditions: User wants to cat this directory.
// Postconditions: Throws runtime_error.
void Directory::cat() const
{
	throw std::runtime_error("cat: " + this->getName() + ": Is a directory");
}

// Preconditions: User wants to remove a specific named file from this directory.
// Postconditions: Removes file from files vector and deletes it <erase>
void Directory::removeFile(const string &name)
{
	for (auto it = this->files.begin(); it != this->files.end(); ++it)
	{
		if ((*it)->getName() == name)
		{
			delete *it;
			this->files.erase(it);
			return;
		}
	}
}

// Preconditions: User wants to change current directory to this directory.
// Postconditions: Changes current directory to this directory.
void Directory::cd(Shell &shell)
{
	shell.setCurrentDirectory(this);
}
Type: Regular
Name: Executor.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704810937
Content: #include "../includes/Executor.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/File.hpp"
#include "../includes/Directory.hpp"
#include "./Template.cpp"
#include <ctime>
#include <sys/stat.h>
#include <fstream>
#include <dirent.h>
#include <sys/types.h>
#include <fcntl.h>
#include <iomanip>
#include <cstring>
#include <stdexcept>

//****************************************  LS  ****************************************//
namespace
{

	// Getting absolute path of a file only by its name while listing files
	string absPathToRelPath(const Shell &shell, const string &path)
	{
		return path.substr(shell.getCurrentDirectory()->getOwnFilesPath().size(), path.size() - 1);
	}
	// lisiting only current directory '.'
	void listOnlyCurrentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << "."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
	// listing parent directory '..'
	void listParentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getParentDirectory()->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << ".."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
}

namespace
{
	// returns max name length of files in directory to align
	size_t getMaxNameLength(const Directory *directory)
	{
		size_t maxNameLength = 2; // for '.' and '..'
		for (auto file : *directory)
		{
			if (file->getName().length() > maxNameLength)
				maxNameLength = file->getName().length();
		}
		return maxNameLength;
	}
}

namespace Executor
{
	// Precondition: User wants to execute ls command
	// Postcondition: ls command is executed
	// @param directory: current directory
	// @param option: option for ls command
	/*
		ls command is used to list files and directories in current directory.
		ls command's '-R' option has a special print format. Firstly it prints current directory's files and directories.
		Then it prints subdirectories' files and directories recursively.
	*/
	void ls(const Directory *directory, const Shell &Shell, const string &option)
	{
		size_t	maxNameLength = getMaxNameLength(directory); // for align
		listOnlyCurrentDirectory(cout, directory, maxNameLength); // listing '.' is a must for ls command
		if (directory != Shell.getRoot()) // listing '..' is a must except root directory
			listParentDirectory(cout, directory, maxNameLength);
		for (auto file : *directory)
			file->print(cout, maxNameLength);
		if (option == "-R")
		{
			for (auto file : *directory)
			{
				if (dynamic_cast<Directory *>(file))
				{
					Directory *directory = dynamic_cast<Directory *>(file);
					cout << "\n";
					Utils::TextEngine::orange();
					cout << "./" << absPathToRelPath(Shell, directory->getOwnFilesPath()) << ":";
					Utils::TextEngine::reset();
					cout << endl;
					ls(directory, Shell, option);
				}
			}
		}
	}
}

//****************************************  LS OVER ****************************************//

//****************************************  CAT  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute cat command
	// Postcondition: cat command is executed
	void cat(const Shell &shell, const string &fileName)
	{
		File	*filePtr = nullptr;

		if (fileName.empty())
			throw runtime_error("cat: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cat: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName); // get absolute path of file
			if (absPath == "/")
				throw runtime_error("cat: " + fileName + ": Is a directory"); // root directory cannot be printed
			filePtr = File::find<File>(shell, absPath);
			if (filePtr == nullptr)
				throw invalid_argument("cat: " + fileName + ": No such file or directory");
			filePtr->cat(); // <polymorphism>
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  CAT OVER ****************************************//

//****************************************  RM  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute rm command
	// Postcondition: rm command is executed
	void	rm(const Shell &shell, const string &fileName)
	{
		File		*filePtr = nullptr;
		Directory	*parentDirectory = nullptr;

		if (fileName.empty())
			throw runtime_error("rm: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("rm: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("rm: cannot remove '" + fileName + "': Is a directory"); // root directory cannot be deleted
			filePtr = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absPath));
			if (filePtr == nullptr)
				throw invalid_argument("rm: cannot remove '" + fileName + "': No such file or directory");
			if (dynamic_cast<Directory *>(filePtr))
				throw invalid_argument("rm: cannot remove '" + fileName + "': Is a directory"); // directory cannot be deleted as you said in pdf
			parentDirectory->removeFile(filePtr->getName()); // remove file from parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  RM OVER ****************************************//
//****************************************  MKDIR  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute mkdir command
	// Postcondition: mkdir command is executed
	// @brief : '' Makes or removes a directory '' as pdf says
	void mkdir(const Shell &shell, const string &fileName)
	{
		File		*directory = nullptr;
		Directory	*parentDirectory = nullptr;
		if (fileName.empty())
			throw runtime_error("mkdir: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists"); // root directory cannot be created and deleted
			string pPath = Utils::getParentPathOfAbsPath(absPath);
			if (pPath == "/")
				pPath = ""; // if parent directory is root directory, parent directory's path is empty
			directory = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, pPath);
			if (directory != nullptr) // delete if existent file is directory and throw exception if not
			{
				if (dynamic_cast<Directory *>(directory)) // if file is directory
				{
					parentDirectory->removeFile(absPath.substr(absPath.find_last_of('/') + 1)); // remove directory from parent directory
					parentDirectory->setTime(time(nullptr));
				}
				else
					throw invalid_argument("mkdir: cannot create directory '" + fileName + "': File exists"); // if file is not directory throw exception
				return;
			}
			else if (parentDirectory == nullptr) // if parent directory does not exist throw exception <for root directory parent directory manipulalated as root too at find function>
				throw invalid_argument("mkdir: cannot create directory '" + fileName + "': No such file or directory");
			string name = absPath.substr(absPath.find_last_of('/') + 1);
			if (parentDirectory == shell.getRoot()) // if parent directory is root directory
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath(), parentDirectory);
			else
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath() + parentDirectory->getName() + "/", parentDirectory);
			parentDirectory->addFile(directory); // add directory to parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}
//****************************************  MKDIR OVER ****************************************//
//****************************************  CD  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute cd command
	// Postcondition: cd command is executed
	// @brief : '' Changes the current directory '' as pdf says
	// @brief '.' and '..' are special cases for cd command and empty string is special case for cd command
	// @brief if directory is not existent throw exception
	void	cd(Shell &shell, const string &directoryName)
	{
		File	*directory = nullptr;
		if (directoryName.empty()) // if directory name is empty set current directory to root directory
			shell.setCurrentDirectory(shell.getRoot());
		else if (directoryName == ".") // if directory name is '.' do nothing
			return;
		else if (directoryName == "..") // if directory name is '..' set current directory to parent directory
		{
			if (shell.getCurrentDirectory() == shell.getRoot()) // if current directory is root directory do nothing
				return;
			shell.setCurrentDirectory(shell.getCurrentDirectory()->getParentDirectory());
		}
		else
		{
			try
			{
				string pPath = Utils::relPathToAbsPath(shell, directoryName);
				if (pPath == "/")
				{
					shell.setCurrentDirectory(shell.getRoot());
					return;
				}
				directory = File::find<File>(shell, pPath);
				if (directory == nullptr)
					throw invalid_argument("cd: " + directoryName + ": No such file or directory");
				directory->cd(shell); // <polymorphism>
			}
			catch (const invalid_argument &e)
			{
				throw e;
			}
		}
	}
}

// ****************************************  CD OVER ****************************************//
// ****************************************  CP  ****************************************//

namespace
{
	// Precondition: User wants to execute cp command and source is a regular file
	// Postcondition: cp command is executed and source is copied to destination
	// @brief : '' Copies file and directory from our original os '' as pdf says
	RegularFile	*copyRegularFile(const string &source, const string &fileName, const struct stat &sourceStat, const string &path)
	{
		ifstream	sourceFile(source);
		RegularFile	*regularFile;
		string		data, line;
		if (!sourceFile.is_open())
			throw runtime_error("cp: source file '" + source + "' does not exist");
		while (getline(sourceFile, line)) // read file line by line
		{
			data += line + "\n";
		}
		data = data.substr(0, data.size() - 2);
		data += static_cast<char>(3); // end of text character
		sourceFile.close();
		regularFile = new RegularFile(fileName, data.size(), sourceStat.st_mtime, data, path); // create regular file
		return regularFile;
	}
}

namespace
{
	// Precondition: User wants to execute cp command and source is a directory
	// Postcondition: cp command is executed and source is copied to destination
	Directory *copyDirectory(const string &source, const string &fileName, const Shell &shell, const struct stat &sourceStat, const string &path, Directory *parentDirectory)
	{
		Directory	*directory; // directory to be copied

		DIR *copiedDir = opendir(source.c_str()); // open directory
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		struct dirent *entry; // entry of directory
		directory = new Directory(fileName, sourceStat.st_mtime, path, parentDirectory); // create directory
		while ((entry = readdir(copiedDir)) != nullptr) // read the directory until end
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) // ignore '.' and '..'
			{
				std::string entryPath = source + "/" + entry->d_name; // get entry's path

				struct stat entryStat; // entry's stat
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'"); // if stat cannot be accessed throw exception and exit
				}
				if (S_ISREG(entryStat.st_mode))
				{
					// Copy regular file
					RegularFile *regularFile = copyRegularFile(entryPath, entry->d_name, entryStat, directory->getOwnFilesPath());
					directory->addFile(regularFile); // add regular file to directory
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					// Recursively copy subdirectories
					Directory *subDirectory = copyDirectory(entryPath, entry->d_name, shell, entryStat, directory->getOwnFilesPath(), directory);
					directory->addFile(subDirectory); // add subdirectory to directory
				}
			}
		}
		closedir(copiedDir); // close directory
		return (directory);
	}
}

namespace
{
	// Precondition: User wants to execute cp command so program gets the size of directory
	// Postcondition: Returns the size of directory
	size_t getDirectorySize(const struct stat &sourcestat, const string &source)
	{
		DIR *copiedDir = opendir(source.c_str());
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		(void)sourcestat; // unused
		struct dirent *entry;
		size_t size = 0;
		while ((entry = readdir(copiedDir)) != nullptr)
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0)
			{
				std::string entryPath = source + "/" + entry->d_name;

				struct stat entryStat;
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'");
				}

				if (S_ISREG(entryStat.st_mode))
				{
					size += entryStat.st_size;
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					size += getDirectorySize(entryStat, entryPath); // recursively get subdirectories' size
				}
			}
		}
		closedir(copiedDir);
		return (size);
	}
}

namespace
{
	// Precondition: User wants to execute cp command
	// Postcondition: cp command is executed and source is copied to destination
	void onlyAddToDirectory(const Shell &shell, const string &source, const string &fileName, const struct stat &sourceStat)
	{

		if (S_ISREG(sourceStat.st_mode))
		{
			RegularFile *regularFile = copyRegularFile(source, fileName, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath());
			shell.getCurrentDirectory()->addFile(regularFile);
			shell.getCurrentDirectory()->setTime(time(nullptr));
		}
		else if (S_ISDIR(sourceStat.st_mode))
		{
			Directory *directory = copyDirectory(source, fileName, shell, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath(), shell.getCurrentDirectory());
			shell.getCurrentDirectory()->addFile(directory);
		}
		shell.getCurrentDirectory()->setTime(time(nullptr));
	}
}

namespace Executor
{
	// Precondition: User wants to execute cp command
	// Postcondition: program executes cp command
	void cp(const Shell &shell, const string &source, const string &fileName)
	{

		struct stat	sourceStat;
		File		*file = nullptr;

		if (source.empty() || fileName.empty())
			throw runtime_error("cp: missing operand");
		if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists");
		if (stat(source.c_str(), &sourceStat) != 0)
		{
			throw std::runtime_error("cp: source file '" + source + "' does not exist"); // if stat cannot be accessed throw exception and exit
		}
		file = File::find<File>(shell, shell.getCurrentDirectory()->getOwnFilesPath() + fileName);
		if (file != nullptr)
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists"); // if file exists throw exception
		if (S_ISREG(sourceStat.st_mode) && sourceStat.st_size + Utils::getProgramSize(shell) > shell.getOsSize()) // size of file + size of program > size of os
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		if (S_ISDIR(sourceStat.st_mode) && getDirectorySize(sourceStat, source) + Utils::getProgramSize(shell) > shell.getOsSize())
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		onlyAddToDirectory(shell, source, fileName, sourceStat); // add file to current directory
	}
}

// ****************************************  CP OVER ****************************************//
// ****************************************  LINK  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute link command
	// Postcondition: program executes link command
	void link(const Shell &shell, const string &source, const string &dest)
	{
		Directory		*destDirectory = nullptr;
		Directory		*sourceDirectory = nullptr;
		File			*sourceFile = nullptr;
		File			*destFile = nullptr;
		SymbolicLink	*symbolicLink = nullptr; // symbolic link to be created

		string absSourcePath = Utils::relPathToAbsPath(shell, source);
		string absDestPath = Utils::relPathToAbsPath(shell, dest);
		if (dest.empty() || source.empty())
			throw runtime_error("link: missing operand");
		else if (dest == "." || dest == ".." || dest == "/")
			throw runtime_error("link: cannot create link '" + dest + "': File exists");
		try
		{
			destFile = File::find<File>(shell, absDestPath);
			destDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absDestPath));
			if (destDirectory == nullptr) // if destination directory does not exist throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': No such file or directory");
			if (destFile != nullptr) // if destination file exists throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': File exists");
			sourceFile = File::find<File>(shell, absSourcePath);
			sourceDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absSourcePath));
			if (sourceDirectory == nullptr){
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), Utils::getParentPathOfAbsPath(absSourcePath) + "/");
			}
			else {
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), sourceDirectory->getOwnFilesPath());
			}
			destDirectory->addFile(symbolicLink); // add symbolic link to destination directory
			destDirectory->setTime(time(nullptr)); // set destination directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

// ****************************************  LINK OVER ****************************************//
Type: Regular
Name: File.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704805811
Content: #include "../includes/File.hpp"

File::File(const string &name, time_t time, const string& path)
	: name(name) , path(path) ,time(time)
{/*Body inintentionally left empty! */}


File::~File()
{/*Body inintentionally left empty! */}
Type: Regular
Name: LoadFile.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704806200
Content: #include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include <fstream>
#include <string>
#include <ctime>
#include <sstream>
#include <stdexcept>

using namespace std;

// Precondition: program wants to load regular file
// Postcondition: regular file is loaded
void LoadFile::addRegularFile(Shell &shell, ifstream &file)
{
	string name, path, time, data;
	Directory *directory = shell.getRoot();
	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	data = Utils::getData(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		directory = shell.getRoot();
		directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
		return;
	}
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem may not be configrated ! ");
	directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
}

// Precondition: program wants to load directory
// Postcondition: directory is loaded
void LoadFile::addDirectory(Shell &shell, ifstream &file)
{
	string name, path, time;
	Directory *parentDirectory;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		parentDirectory = shell.getRoot();
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
	else
	{
		parentDirectory = File::find<Directory>(shell, path);
		if (parentDirectory == nullptr)
			throw runtime_error("Directory coould not be found.");
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
}

// Precondition: program wants to load symbolic link
// Postcondition: symbolic link is loaded
void LoadFile::addSymbolicLink(Shell &shell, ifstream &file)
{
	string name, path, time, linkPath, linkerName;
	File *link = nullptr;
	Directory *directory = nullptr;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	linkPath = Utils::getContent(file);
	linkerName = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	link = File::find<File>(shell, linkPath + linkerName);
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem file is broken"); // not configrated
	directory->addFile(new SymbolicLink(name, path, time_t_time, link, linkerName, linkPath));
}

// Precondition: program wants to load file system
// Postcondition: file system is loaded
void LoadFile::load(const std::string &path, Shell &shell)
{
	ifstream file(path);

	if (!file.is_open())
		throw runtime_error("File could not be opened.");
	string lineTmp;			// to ignore first line for roots time
	getline(file, lineTmp); // ignore first line
	while (!file.eof())
	{
		string line;
		getline(file, line);
		line = Utils::trim(line);
		if (line.empty())
			continue;
		if (line.substr(line.find(" ") + 1, line.size() - 1) == "Regular")
		{
			addRegularFile(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Directory")
		{
			addDirectory(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Link")
		{
			addSymbolicLink(shell, file);
		}
		else
		{
			throw runtime_error("Filesystem is not in correct format.");
		}
	}
	Utils::recheckLinks(shell, shell.getRoot()); // recheck links because they may be linked after loading file system
	file.close();
}
Type: Regular
Name: main.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704806226
Content: #include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include <iostream>

int main(){

	try {
		Shell	shell;
		LoadFile::load(shell.getFileSystemPath(), shell); // loading file system
		while (!shell.isTerminated()) {
			try {
				Utils::printPrompt(shell); // printing prompt
				string	command;
				getline(cin, command); // getting command
				Utils::TextEngine::reset();
				shell.execute(command); // executing command
			} catch (const exception& e) {
				Utils::TextEngine::bold();
				Utils::TextEngine::red();
				cerr << e.what();
				Utils::TextEngine::reset();
				cout << endl;
			}
		}
	} catch (const exception& e) {
		Utils::TextEngine::bold();
		Utils::TextEngine::red();
		cerr << e.what();
		Utils::TextEngine::reset();
		cout << endl;
	}
}
Type: Regular
Name: RegularFile.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704806455
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

RegularFile::RegularFile(const string &name, size_t sizeBytes, time_t time, const string &data, const string &path)
	: File(name, time, path), sizeBytes(sizeBytes), data(data)
{ /*Body inintentionally left empty! */
}

RegularFile::~RegularFile()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void RegularFile::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "F ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << this->getSizeBytes() << " Bytes";
	Utils::TextEngine::reset();
	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void RegularFile::save(std::ostream &file) const
{
	file << "Type: Regular" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Content: " << getData() << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void RegularFile::cat() const
{
	for (auto it : *this) // iterator (I know it is not a good way to do this but I wanted to use iterator)
	{
		std::cout << it;
	}
	std::cout << std::endl;
}

// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void RegularFile::cd(Shell &shell) // throws exception because it is not a directory
{
	(void)shell; // unused parameter but I need it to override the virtual function
	throw std::runtime_error("cd :" + getName() + " : Not a directory");
}
Type: Regular
Name: SaveFile.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704806561
Content: #include "../includes/SaveFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include <fstream>
#include <stdexcept>

namespace
{
	// recursive function that saves subdirectories and files
	void recursive(std::ofstream &file, Directory *directory)
	{
		for (auto vfile = directory->getFiles().begin(); vfile != directory->getFiles().end(); ++vfile)
		{
			(*vfile)->save(file);
			if (dynamic_cast<Directory *>(*vfile) != nullptr)
			{
				Directory *vdFile = dynamic_cast<Directory *>(*vfile);
				recursive(file, vdFile);
			}
		}
	}
}

// Precondition: program wants to save the current state of the shell to a file
// Postcondition: the current state of the shell is saved to a file
void SaveFile::save(const std::string &path, Shell &shell)
{
	std::ofstream file(path);
	if (!file.is_open())
	{
		throw std::runtime_error("File cannot be opened!");
	}
	file << "Time: " << shell.getRoot()->getTime() << std::endl;
	for (const auto &vfile : shell.getRoot()->getFiles())
	{
		if (vfile != nullptr)
		{
			vfile->save(file);
			if (dynamic_cast<Directory *>(vfile) != nullptr) // if it is a directory then call recursive function
			{
				Directory *vdFile = dynamic_cast<Directory *>(vfile);
				recursive(file, vdFile); // recursive function
			}
		}
	}
	file.close();
}
Type: Regular
Name: Shell.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704811871
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/SaveFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/Executor.hpp"
#include <fstream>
#include <string>
#include <stdexcept>

const std::string Shell::fileSystemPath = "./os/filesystem.txt";

Shell::Shell() : isTerminating(false), prompt("/$ ")
{
	std::ifstream file(fileSystemPath);
	time_t timeT;
	string timeStr;
	if (!file.is_open())
		throw std::runtime_error("filesystem.txt not found");
	timeStr = Utils::getContent(file);
	timeT = std::stoi(timeStr);
	this->root = new Directory("/", timeT, "/");
	this->currentDirectory = this->root;
	file.close();
}

/* destructor : deletes root directory \
	deleting root directory deletes all files in it recursively. \
	because delete calls each files destructor and deletes them. */
Shell::~Shell()
{
	delete this->root;
}

void Shell::execute(string command)
{
	if (command == "")
		return;
	command = Utils::trim(command);
	vector<string> commandSplit = Utils::split(command, ' ');
	string commandName = commandSplit[0];

	if (commandName == "exit")
	{
		this->setTerminated(true);
		SaveFile::save(Shell::getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "ls")
	{
		if (commandSplit.size() == 1)
			Executor::ls(getCurrentDirectory(), *this, "");
		else if (commandSplit[1] == "-R"){
			Executor::ls(getCurrentDirectory(), *this, commandSplit[1]);
		}
		else
			throw runtime_error("ls: invalid option for cemalBolatShell -- '" + command + "'");
		return;
	}
	else if (commandName == "cat")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cat: invalid number of arguments for cemalBolatShell -- ");
		else
			Executor::cat(*this, commandSplit[1]);
		return;
	}
	else if (commandName == "rm")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("rm: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::rm(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "mkdir")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("mkdir: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::mkdir(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "cd")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cd: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::cd(*this, commandSplit[1]);
			if (getCurrentDirectory()->getName() == "/")
				this->setPrompt("/$ ");
			else
				setPrompt(getCurrentDirectory()->getPath() + getCurrentDirectory()->getName() + "$ ");
			return;
		}
	}
	else if (commandName == "cp")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("cp: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("cp: invalid number of arguments for cemalBolatShell -- ");
		else if (commandSplit[1] == "." || commandSplit[1] == ".." || commandSplit[1] == "/")
			throw runtime_error("cp: cannot copy to " + commandSplit[1] + ": file exists");
		Executor::cp(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "link")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("link: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("link: invalid number of arguments for cemalBolatShell -- ");
		Executor::link(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else
		throw invalid_argument("cemalBolatShell: " + commandName + ": command not found");
}
Type: Regular
Name: SymbolicLink.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704806816
Content: #include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

SymbolicLink::SymbolicLink(const string &name, const string &path, time_t time, File *link, const string &linkedName, const string &linkPath)
	: File(name, time, path), link(link), linkedName(linkedName), linkPath(linkPath)
{ /*Body inintentionally left empty! */
}

SymbolicLink::~SymbolicLink()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void SymbolicLink::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::red();
	os << "L ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << "2 Bytes ";
	Utils::TextEngine::reset();
	Utils::TextEngine::yellow();
	Utils::TextEngine::bold();
	os << this->getName() << " -> " << this->getLinkedPath() + this->getLinkedName();
	Utils::TextEngine::reset();

	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void SymbolicLink::save(std::ostream &file) const
{
	file << "Type: Link" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Link: " << linkPath << std::endl;
	file << "LinkedName: " << linkedName << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void SymbolicLink::cat() const
{
	if (link == nullptr)
	{
		throw std::runtime_error("cat :" + getName() + " : No such file or directory");
	}
	link->cat(); // if link is symbolic link, it will call this function again
}


// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void SymbolicLink::cd(Shell &shell)
{
	if (link == nullptr)
	{
		throw std::runtime_error("cd :" + getName() + " : No such file or directory");
	}
	link->cd(shell); // if link is symbolic link, it will call this function again

Type: Regular
Name: Template.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704801868
Content: #include "../includes/Utils.hpp"
#include "../includes/Directory.hpp"
#include <memory>

template <typename T>
T	*findTraverse(Directory *directory, const vector<string> &path)
{
	for (auto file : *directory){
		if (file->getName() == path[0])
		{
			if (path.size() == 1)
			{
				if (dynamic_cast<T *>(file))
					return dynamic_cast<T *>(file);
			}
			else
			{
				return findTraverse<T>(dynamic_cast<Directory *>(file), vector<string>(path.begin() + 1, path.end()));
			}
		}
	}
	return nullptr;
}

template <>
Directory	*File::find<Directory>(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	if (paths.size() == 0)
	{
		return shell.getRoot();
	}
	return (findTraverse<Directory>(shell.getRoot(), paths));
}

template <typename T>
T	*File::find(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	return (findTraverse<T>(shell.getRoot(), paths));

Type: Regular
Name: TextEngine.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704299052
Content: #include "../includes/TextEngine.hpp"
#include <iostream>
using namespace std;


namespace Utils {
	// namespace : TextEngine is for text coloring in terminal
	namespace TextEngine {
		void	yellow() { cout << ANSI_FG_YELLOW; }
		void	red() { cout << ANSI_FG_RED; }
		void	green() { cout << ANSI_FG_GREEN; }
		void	blue() { cout << ANSI_FG_BLUE; }
		void	reset() {cout << ANSI_RESET; }
		void	bold() { cout << ANSI_BOLD; }
		void	underline() { cout << ANSI_UNDERLINE;}
		void	blink() { cout << ANSI_BLINK;}
		void	black() { cout << ANSI_FG_BLACK; }
		void	magenta() { cout << ANSI_FG_MAGENTA; }
		void	cyan() { cout << ANSI_FG_CYAN; }
		void	white() { cout << ANSI_FG_WHITE; }
		void	redBackground() { cout << ANSI_BG_RED; }
		void	greenBackground() { cout << ANSI_BG_GREEN; }
		void	blueBackground() { cout << ANSI_BG_BLUE; }
		void	yellowBackground() { cout << ANSI_BG_YELLOW; }
		void	blackBackground() { cout << ANSI_BG_BLACK; }
		void	magentaBackground() { cout << ANSI_BG_MAGENTA; }
		void	cyanBackground() { cout << ANSI_BG_CYAN; }
		void	whiteBackground() { cout << ANSI_BG_WHITE; }
		void	resetBackground() { cout << "\033[49m"; }
		void	resetForeground() { cout << "\033[39m"; }
		void	resetAll() { cout << "\033[0m"; }
		void	orange() { cout << "\033[38;5;208m"; }
	}

Type: Regular
Name: Utils.cpp
Path: /gtu/cse/cse107/lab_notes/
Time: 1704806924
Content: #include "../includes/Utils.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include <iomanip>
#include <vector>
#include <sstream>
#include <sys/stat.h>
#include <stdexcept>

using namespace std;

namespace
{
	// Precondition: month is between 1 and 12
	// Postcondition: returns the string of month
	string convertMonth(int month)
	{
		switch (month)
		{
		case 1: return "Jan";
		case 2: return "Feb";
		case 3: return "Mar";
		case 4: return "Apr";
		case 5: return "May";
		case 6: return "Jun";
		case 7: return "Jul";
		case 8: return "Aug";
		case 9: return "Sep";
		case 10: return "Oct";
		case 11: return "Nov";
		default: return "Dec";
		}
	}
}

namespace Utils
{
	// Precondition: str is a string
	// Postcondition: returns the vector of splitted string by delim
	vector<string> split(const string &str, char delim)
	{
		std::vector<std::string> elems;
		std::stringstream ss(str);
		std::string item;
		while (std::getline(ss, item, delim))
		{
			if (!item.empty())
				elems.push_back(item);
		}
		return elems;
	}
	// Precondition: str is a string
	// Postcondition: returns the trimmed string
	string trim(const std::string &str)
	{
		size_t first = str.find_first_not_of(" \t\r");
		size_t last = str.find_last_not_of(" \t\r");

		if (first == std::string::npos || last == std::string::npos)
			return "";

		return str.substr(first, last - first + 1);
	}
	// Precondition : file is a ifstream
	// Postcondition: returns the content of file (without spaces)
	string getContent(std::ifstream &file)
	{
		string content;
		getline(file, content);
		content = trim(content);
		if (content.empty())
			throw runtime_error("File content is not configrated!");
		return content.substr(content.find(" ") + 1, content.size() - 1);
	}
	// Precondition: timeinfo is a struct tm
	// Postcondition: prints the timeinfo to os
	ostream &printTime(ostream &os, struct tm *timeinfo)
	{
		int day = timeinfo->tm_mday;
		int month = timeinfo->tm_mon + 1;
		int hour = timeinfo->tm_hour;
		int minute = timeinfo->tm_min;

		os << std::right << std::setw(3) << std::setfill('0') << convertMonth(month) << " "
		   << std::right << std::setw(2) << std::setfill('0') << day << " "
		   << std::right << std::setw(2) << std::setfill('0') << hour << ":"
		   << std::right << std::setw(2) << std::setfill('0') << minute << " ";
		return os;
	}
	// Precondition: file is a ifstream
	// Postcondition: returns the data of file
	string getData(std::ifstream &file)
	{
		string data;
		string line;
		getline(file, line);
		data = line.substr(line.find(" ") + 1, line.size() - 1);
		if (data[data.size() - 1] == static_cast<char>(3))
		{
			return data;
		}
		data += "\n";
		while (getline(file, line))
		{
			trim(line);
			data += line;
			if (!line.empty() && line[line.size() - 1] == static_cast<char>(3))
			{
				break;
			}
			data += "\n";
		}
		line += static_cast<char>(3);
		return data;
	}
	// Precondition: path is a string
	// Postcondition: returns the absolute path of path
	string relPathToAbsPath(const Shell &shell, const std::string &path)
	{
		string relPathToAbsPath;
		vector<string> relPathToAbsPathSplit;
		vector<string> relPathToAbsPathSplitTmp;
		if (path[0] == '/')
			relPathToAbsPathSplit = Utils::split(path, '/');
		else
		{
			relPathToAbsPathSplit = Utils::split(shell.getCurrentDirectory()->getOwnFilesPath() + "/" + path, '/');
		}
		if (relPathToAbsPathSplit.size() == 0)
			return "/";
		for (auto &path : relPathToAbsPathSplit)
		{
			// std::cout << path << std::endl;
			if (path == ".")
				continue;
			else if (path == "..")
			{
				if (relPathToAbsPathSplitTmp.size() > 0)
					relPathToAbsPathSplitTmp.pop_back();
			}
			else
				relPathToAbsPathSplitTmp.push_back(path);
		}
		relPathToAbsPath = "";
		for (auto &path : relPathToAbsPathSplitTmp)
		{
			relPathToAbsPath += "/" + path;
		}
		if (relPathToAbsPath == "")
			relPathToAbsPath = "/";
		return relPathToAbsPath;
	}

	string getParentPathOfAbsPath(const string &absPath)
	{
		size_t found = absPath.find_last_of('/');
		if (found != std::string::npos)
		{
			if (found == 0)
				return "/";
			return absPath.substr(0, found);
		}
		return "/";
	}
}

namespace Utils
{
	// Precondition: directory is a Directory
	// Postcondition: returns the size of directory recursively
	// Note: size of directory is the sum of size of its files and its subdirectories recursively + 15 is the size of saving system information
	size_t getProgramSize(const Shell &Shell)
	{
		struct stat st;
		stat(Shell.getFileSystemPath().c_str(), &st);
		return st.st_size;
	}
}

namespace Utils
{
	// Precondition: shell is a Shell
	// Postcondition: rechecks the links of shell recursively because of the possibility of deleting linked files or creating new files for linking to them
	void recheckLinks(Shell &shell, Directory *directory)
	{
		for (auto it = directory->getFiles().begin(); it != directory->getFiles().end(); ++it)
		{
			if (dynamic_cast<SymbolicLink *>(*it) != nullptr)
			{ // if file is a symbolic link
				SymbolicLink *link = dynamic_cast<SymbolicLink *>(*it);
				File *linkFile = File::find<File>(shell, link->getLinkedPath() + "/" + link->getLinkedName());
				link->setLink(linkFile);
			}
			else if (dynamic_cast<Directory *>(*it) != nullptr)
			{ // if file is a directory then recursive call
				Directory *dir = dynamic_cast<Directory *>(*it);
				recheckLinks(shell, dir);
			}
		}
	}
}

namespace Utils {
	// prints the prompt properly
	void printPrompt(const Shell &shell) {
		Utils::TextEngine::green();
		Utils::TextEngine::bold();
		cout << "cemalBolat@C++0S:";
		Utils::TextEngine::reset();
		Utils::TextEngine::bold();
		Utils::TextEngine::blue();
		cout << shell.getPrompt();
		Utils::TextEngine::magenta();
	}
}
Type: Directory
Name: cse108
Path: /gtu/cse/
Time: 1704812967
Type: Directory
Name: lab_notes
Path: /gtu/cse/cse108/
Time: 1704299052
Type: Regular
Name: Directory.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704802991
Content: #include "../includes/Directory.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/Shell.hpp"
#include <ctime>		// std::localtime
#include <sstream>		// std::stringstream
#include <iomanip>		// std::setw
#include <stdexcept>	// std::runtime_error

// constructor for root directory
Directory::Directory(const string &name, time_t time, const string &path)
	: File(name, time, path), ownFilesPath("/"), parentDirectory(nullptr)
{
	files = vector<File *>();
}

// constructor for other directories
Directory::Directory(const string &name, time_t time, const string &path, Directory *parentDirectory)
	: File(name, time, path), ownFilesPath(path + name + "/"), parentDirectory(parentDirectory)
{
	files = vector<File *>();
}

// destructor : delete calls each files destructor and deletes them.
// then deletes itself.
Directory::~Directory()
{
	for (auto file : this->files)
		delete file;
}

// Preconditions: User wants to add a file to this directory.
// Postconditions: Adds file to files vector. <push_back>
void Directory::addFile(File *file)
{
	this->files.push_back(file);
}

// Preconditions: User wants to print the information about this directory with using ls or something.
// Postconditions: Prints the information about this directory. <colorful way>
void Directory::print(std::ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "D ";
	Utils::TextEngine::reset();
	Utils::TextEngine::bold();
	Utils::TextEngine::cyan();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();

	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::resetAll();
	os << std::endl;
}

// Preconditions : Progaram wants to save this directory to filesystem.txt file.
// Postconditions : Saves this directory to filesystem.txt file.
void Directory::save(std::ostream &file) const
{
	file << "Type: Directory" << std::endl;
	file << "Name: " << this->getName() << std::endl;
	file << "Path: " << this->getPath() << std::endl;
	file << "Time: " << this->getTime() << std::endl;
}

// Preconditions: User wants to cat this directory.
// Postconditions: Throws runtime_error.
void Directory::cat() const
{
	throw std::runtime_error("cat: " + this->getName() + ": Is a directory");
}

// Preconditions: User wants to remove a specific named file from this directory.
// Postconditions: Removes file from files vector and deletes it <erase>
void Directory::removeFile(const string &name)
{
	for (auto it = this->files.begin(); it != this->files.end(); ++it)
	{
		if ((*it)->getName() == name)
		{
			delete *it;
			this->files.erase(it);
			return;
		}
	}
}

// Preconditions: User wants to change current directory to this directory.
// Postconditions: Changes current directory to this directory.
void Directory::cd(Shell &shell)
{
	shell.setCurrentDirectory(this);
}
Type: Regular
Name: Executor.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704810937
Content: #include "../includes/Executor.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/File.hpp"
#include "../includes/Directory.hpp"
#include "./Template.cpp"
#include <ctime>
#include <sys/stat.h>
#include <fstream>
#include <dirent.h>
#include <sys/types.h>
#include <fcntl.h>
#include <iomanip>
#include <cstring>
#include <stdexcept>

//****************************************  LS  ****************************************//
namespace
{

	// Getting absolute path of a file only by its name while listing files
	string absPathToRelPath(const Shell &shell, const string &path)
	{
		return path.substr(shell.getCurrentDirectory()->getOwnFilesPath().size(), path.size() - 1);
	}
	// lisiting only current directory '.'
	void listOnlyCurrentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << "."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
	// listing parent directory '..'
	void listParentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getParentDirectory()->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << ".."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
}

namespace
{
	// returns max name length of files in directory to align
	size_t getMaxNameLength(const Directory *directory)
	{
		size_t maxNameLength = 2; // for '.' and '..'
		for (auto file : *directory)
		{
			if (file->getName().length() > maxNameLength)
				maxNameLength = file->getName().length();
		}
		return maxNameLength;
	}
}

namespace Executor
{
	// Precondition: User wants to execute ls command
	// Postcondition: ls command is executed
	// @param directory: current directory
	// @param option: option for ls command
	/*
		ls command is used to list files and directories in current directory.
		ls command's '-R' option has a special print format. Firstly it prints current directory's files and directories.
		Then it prints subdirectories' files and directories recursively.
	*/
	void ls(const Directory *directory, const Shell &Shell, const string &option)
	{
		size_t	maxNameLength = getMaxNameLength(directory); // for align
		listOnlyCurrentDirectory(cout, directory, maxNameLength); // listing '.' is a must for ls command
		if (directory != Shell.getRoot()) // listing '..' is a must except root directory
			listParentDirectory(cout, directory, maxNameLength);
		for (auto file : *directory)
			file->print(cout, maxNameLength);
		if (option == "-R")
		{
			for (auto file : *directory)
			{
				if (dynamic_cast<Directory *>(file))
				{
					Directory *directory = dynamic_cast<Directory *>(file);
					cout << "\n";
					Utils::TextEngine::orange();
					cout << "./" << absPathToRelPath(Shell, directory->getOwnFilesPath()) << ":";
					Utils::TextEngine::reset();
					cout << endl;
					ls(directory, Shell, option);
				}
			}
		}
	}
}

//****************************************  LS OVER ****************************************//

//****************************************  CAT  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute cat command
	// Postcondition: cat command is executed
	void cat(const Shell &shell, const string &fileName)
	{
		File	*filePtr = nullptr;

		if (fileName.empty())
			throw runtime_error("cat: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cat: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName); // get absolute path of file
			if (absPath == "/")
				throw runtime_error("cat: " + fileName + ": Is a directory"); // root directory cannot be printed
			filePtr = File::find<File>(shell, absPath);
			if (filePtr == nullptr)
				throw invalid_argument("cat: " + fileName + ": No such file or directory");
			filePtr->cat(); // <polymorphism>
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  CAT OVER ****************************************//

//****************************************  RM  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute rm command
	// Postcondition: rm command is executed
	void	rm(const Shell &shell, const string &fileName)
	{
		File		*filePtr = nullptr;
		Directory	*parentDirectory = nullptr;

		if (fileName.empty())
			throw runtime_error("rm: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("rm: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("rm: cannot remove '" + fileName + "': Is a directory"); // root directory cannot be deleted
			filePtr = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absPath));
			if (filePtr == nullptr)
				throw invalid_argument("rm: cannot remove '" + fileName + "': No such file or directory");
			if (dynamic_cast<Directory *>(filePtr))
				throw invalid_argument("rm: cannot remove '" + fileName + "': Is a directory"); // directory cannot be deleted as you said in pdf
			parentDirectory->removeFile(filePtr->getName()); // remove file from parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  RM OVER ****************************************//
//****************************************  MKDIR  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute mkdir command
	// Postcondition: mkdir command is executed
	// @brief : '' Makes or removes a directory '' as pdf says
	void mkdir(const Shell &shell, const string &fileName)
	{
		File		*directory = nullptr;
		Directory	*parentDirectory = nullptr;
		if (fileName.empty())
			throw runtime_error("mkdir: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists"); // root directory cannot be created and deleted
			string pPath = Utils::getParentPathOfAbsPath(absPath);
			if (pPath == "/")
				pPath = ""; // if parent directory is root directory, parent directory's path is empty
			directory = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, pPath);
			if (directory != nullptr) // delete if existent file is directory and throw exception if not
			{
				if (dynamic_cast<Directory *>(directory)) // if file is directory
				{
					parentDirectory->removeFile(absPath.substr(absPath.find_last_of('/') + 1)); // remove directory from parent directory
					parentDirectory->setTime(time(nullptr));
				}
				else
					throw invalid_argument("mkdir: cannot create directory '" + fileName + "': File exists"); // if file is not directory throw exception
				return;
			}
			else if (parentDirectory == nullptr) // if parent directory does not exist throw exception <for root directory parent directory manipulalated as root too at find function>
				throw invalid_argument("mkdir: cannot create directory '" + fileName + "': No such file or directory");
			string name = absPath.substr(absPath.find_last_of('/') + 1);
			if (parentDirectory == shell.getRoot()) // if parent directory is root directory
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath(), parentDirectory);
			else
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath() + parentDirectory->getName() + "/", parentDirectory);
			parentDirectory->addFile(directory); // add directory to parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}
//****************************************  MKDIR OVER ****************************************//
//****************************************  CD  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute cd command
	// Postcondition: cd command is executed
	// @brief : '' Changes the current directory '' as pdf says
	// @brief '.' and '..' are special cases for cd command and empty string is special case for cd command
	// @brief if directory is not existent throw exception
	void	cd(Shell &shell, const string &directoryName)
	{
		File	*directory = nullptr;
		if (directoryName.empty()) // if directory name is empty set current directory to root directory
			shell.setCurrentDirectory(shell.getRoot());
		else if (directoryName == ".") // if directory name is '.' do nothing
			return;
		else if (directoryName == "..") // if directory name is '..' set current directory to parent directory
		{
			if (shell.getCurrentDirectory() == shell.getRoot()) // if current directory is root directory do nothing
				return;
			shell.setCurrentDirectory(shell.getCurrentDirectory()->getParentDirectory());
		}
		else
		{
			try
			{
				string pPath = Utils::relPathToAbsPath(shell, directoryName);
				if (pPath == "/")
				{
					shell.setCurrentDirectory(shell.getRoot());
					return;
				}
				directory = File::find<File>(shell, pPath);
				if (directory == nullptr)
					throw invalid_argument("cd: " + directoryName + ": No such file or directory");
				directory->cd(shell); // <polymorphism>
			}
			catch (const invalid_argument &e)
			{
				throw e;
			}
		}
	}
}

// ****************************************  CD OVER ****************************************//
// ****************************************  CP  ****************************************//

namespace
{
	// Precondition: User wants to execute cp command and source is a regular file
	// Postcondition: cp command is executed and source is copied to destination
	// @brief : '' Copies file and directory from our original os '' as pdf says
	RegularFile	*copyRegularFile(const string &source, const string &fileName, const struct stat &sourceStat, const string &path)
	{
		ifstream	sourceFile(source);
		RegularFile	*regularFile;
		string		data, line;
		if (!sourceFile.is_open())
			throw runtime_error("cp: source file '" + source + "' does not exist");
		while (getline(sourceFile, line)) // read file line by line
		{
			data += line + "\n";
		}
		data = data.substr(0, data.size() - 2);
		data += static_cast<char>(3); // end of text character
		sourceFile.close();
		regularFile = new RegularFile(fileName, data.size(), sourceStat.st_mtime, data, path); // create regular file
		return regularFile;
	}
}

namespace
{
	// Precondition: User wants to execute cp command and source is a directory
	// Postcondition: cp command is executed and source is copied to destination
	Directory *copyDirectory(const string &source, const string &fileName, const Shell &shell, const struct stat &sourceStat, const string &path, Directory *parentDirectory)
	{
		Directory	*directory; // directory to be copied

		DIR *copiedDir = opendir(source.c_str()); // open directory
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		struct dirent *entry; // entry of directory
		directory = new Directory(fileName, sourceStat.st_mtime, path, parentDirectory); // create directory
		while ((entry = readdir(copiedDir)) != nullptr) // read the directory until end
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) // ignore '.' and '..'
			{
				std::string entryPath = source + "/" + entry->d_name; // get entry's path

				struct stat entryStat; // entry's stat
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'"); // if stat cannot be accessed throw exception and exit
				}
				if (S_ISREG(entryStat.st_mode))
				{
					// Copy regular file
					RegularFile *regularFile = copyRegularFile(entryPath, entry->d_name, entryStat, directory->getOwnFilesPath());
					directory->addFile(regularFile); // add regular file to directory
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					// Recursively copy subdirectories
					Directory *subDirectory = copyDirectory(entryPath, entry->d_name, shell, entryStat, directory->getOwnFilesPath(), directory);
					directory->addFile(subDirectory); // add subdirectory to directory
				}
			}
		}
		closedir(copiedDir); // close directory
		return (directory);
	}
}

namespace
{
	// Precondition: User wants to execute cp command so program gets the size of directory
	// Postcondition: Returns the size of directory
	size_t getDirectorySize(const struct stat &sourcestat, const string &source)
	{
		DIR *copiedDir = opendir(source.c_str());
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		(void)sourcestat; // unused
		struct dirent *entry;
		size_t size = 0;
		while ((entry = readdir(copiedDir)) != nullptr)
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0)
			{
				std::string entryPath = source + "/" + entry->d_name;

				struct stat entryStat;
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'");
				}

				if (S_ISREG(entryStat.st_mode))
				{
					size += entryStat.st_size;
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					size += getDirectorySize(entryStat, entryPath); // recursively get subdirectories' size
				}
			}
		}
		closedir(copiedDir);
		return (size);
	}
}

namespace
{
	// Precondition: User wants to execute cp command
	// Postcondition: cp command is executed and source is copied to destination
	void onlyAddToDirectory(const Shell &shell, const string &source, const string &fileName, const struct stat &sourceStat)
	{

		if (S_ISREG(sourceStat.st_mode))
		{
			RegularFile *regularFile = copyRegularFile(source, fileName, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath());
			shell.getCurrentDirectory()->addFile(regularFile);
			shell.getCurrentDirectory()->setTime(time(nullptr));
		}
		else if (S_ISDIR(sourceStat.st_mode))
		{
			Directory *directory = copyDirectory(source, fileName, shell, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath(), shell.getCurrentDirectory());
			shell.getCurrentDirectory()->addFile(directory);
		}
		shell.getCurrentDirectory()->setTime(time(nullptr));
	}
}

namespace Executor
{
	// Precondition: User wants to execute cp command
	// Postcondition: program executes cp command
	void cp(const Shell &shell, const string &source, const string &fileName)
	{

		struct stat	sourceStat;
		File		*file = nullptr;

		if (source.empty() || fileName.empty())
			throw runtime_error("cp: missing operand");
		if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists");
		if (stat(source.c_str(), &sourceStat) != 0)
		{
			throw std::runtime_error("cp: source file '" + source + "' does not exist"); // if stat cannot be accessed throw exception and exit
		}
		file = File::find<File>(shell, shell.getCurrentDirectory()->getOwnFilesPath() + fileName);
		if (file != nullptr)
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists"); // if file exists throw exception
		if (S_ISREG(sourceStat.st_mode) && sourceStat.st_size + Utils::getProgramSize(shell) > shell.getOsSize()) // size of file + size of program > size of os
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		if (S_ISDIR(sourceStat.st_mode) && getDirectorySize(sourceStat, source) + Utils::getProgramSize(shell) > shell.getOsSize())
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		onlyAddToDirectory(shell, source, fileName, sourceStat); // add file to current directory
	}
}

// ****************************************  CP OVER ****************************************//
// ****************************************  LINK  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute link command
	// Postcondition: program executes link command
	void link(const Shell &shell, const string &source, const string &dest)
	{
		Directory		*destDirectory = nullptr;
		Directory		*sourceDirectory = nullptr;
		File			*sourceFile = nullptr;
		File			*destFile = nullptr;
		SymbolicLink	*symbolicLink = nullptr; // symbolic link to be created

		string absSourcePath = Utils::relPathToAbsPath(shell, source);
		string absDestPath = Utils::relPathToAbsPath(shell, dest);
		if (dest.empty() || source.empty())
			throw runtime_error("link: missing operand");
		else if (dest == "." || dest == ".." || dest == "/")
			throw runtime_error("link: cannot create link '" + dest + "': File exists");
		try
		{
			destFile = File::find<File>(shell, absDestPath);
			destDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absDestPath));
			if (destDirectory == nullptr) // if destination directory does not exist throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': No such file or directory");
			if (destFile != nullptr) // if destination file exists throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': File exists");
			sourceFile = File::find<File>(shell, absSourcePath);
			sourceDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absSourcePath));
			if (sourceDirectory == nullptr){
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), Utils::getParentPathOfAbsPath(absSourcePath) + "/");
			}
			else {
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), sourceDirectory->getOwnFilesPath());
			}
			destDirectory->addFile(symbolicLink); // add symbolic link to destination directory
			destDirectory->setTime(time(nullptr)); // set destination directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

// ****************************************  LINK OVER ****************************************//
Type: Regular
Name: File.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704805811
Content: #include "../includes/File.hpp"

File::File(const string &name, time_t time, const string& path)
	: name(name) , path(path) ,time(time)
{/*Body inintentionally left empty! */}


File::~File()
{/*Body inintentionally left empty! */}
Type: Regular
Name: LoadFile.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704806200
Content: #include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include <fstream>
#include <string>
#include <ctime>
#include <sstream>
#include <stdexcept>

using namespace std;

// Precondition: program wants to load regular file
// Postcondition: regular file is loaded
void LoadFile::addRegularFile(Shell &shell, ifstream &file)
{
	string name, path, time, data;
	Directory *directory = shell.getRoot();
	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	data = Utils::getData(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		directory = shell.getRoot();
		directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
		return;
	}
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem may not be configrated ! ");
	directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
}

// Precondition: program wants to load directory
// Postcondition: directory is loaded
void LoadFile::addDirectory(Shell &shell, ifstream &file)
{
	string name, path, time;
	Directory *parentDirectory;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		parentDirectory = shell.getRoot();
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
	else
	{
		parentDirectory = File::find<Directory>(shell, path);
		if (parentDirectory == nullptr)
			throw runtime_error("Directory coould not be found.");
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
}

// Precondition: program wants to load symbolic link
// Postcondition: symbolic link is loaded
void LoadFile::addSymbolicLink(Shell &shell, ifstream &file)
{
	string name, path, time, linkPath, linkerName;
	File *link = nullptr;
	Directory *directory = nullptr;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	linkPath = Utils::getContent(file);
	linkerName = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	link = File::find<File>(shell, linkPath + linkerName);
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem file is broken"); // not configrated
	directory->addFile(new SymbolicLink(name, path, time_t_time, link, linkerName, linkPath));
}

// Precondition: program wants to load file system
// Postcondition: file system is loaded
void LoadFile::load(const std::string &path, Shell &shell)
{
	ifstream file(path);

	if (!file.is_open())
		throw runtime_error("File could not be opened.");
	string lineTmp;			// to ignore first line for roots time
	getline(file, lineTmp); // ignore first line
	while (!file.eof())
	{
		string line;
		getline(file, line);
		line = Utils::trim(line);
		if (line.empty())
			continue;
		if (line.substr(line.find(" ") + 1, line.size() - 1) == "Regular")
		{
			addRegularFile(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Directory")
		{
			addDirectory(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Link")
		{
			addSymbolicLink(shell, file);
		}
		else
		{
			throw runtime_error("Filesystem is not in correct format.");
		}
	}
	Utils::recheckLinks(shell, shell.getRoot()); // recheck links because they may be linked after loading file system
	file.close();
}
Type: Regular
Name: main.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704806226
Content: #include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include <iostream>

int main(){

	try {
		Shell	shell;
		LoadFile::load(shell.getFileSystemPath(), shell); // loading file system
		while (!shell.isTerminated()) {
			try {
				Utils::printPrompt(shell); // printing prompt
				string	command;
				getline(cin, command); // getting command
				Utils::TextEngine::reset();
				shell.execute(command); // executing command
			} catch (const exception& e) {
				Utils::TextEngine::bold();
				Utils::TextEngine::red();
				cerr << e.what();
				Utils::TextEngine::reset();
				cout << endl;
			}
		}
	} catch (const exception& e) {
		Utils::TextEngine::bold();
		Utils::TextEngine::red();
		cerr << e.what();
		Utils::TextEngine::reset();
		cout << endl;
	}
}
Type: Regular
Name: RegularFile.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704806455
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

RegularFile::RegularFile(const string &name, size_t sizeBytes, time_t time, const string &data, const string &path)
	: File(name, time, path), sizeBytes(sizeBytes), data(data)
{ /*Body inintentionally left empty! */
}

RegularFile::~RegularFile()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void RegularFile::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "F ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << this->getSizeBytes() << " Bytes";
	Utils::TextEngine::reset();
	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void RegularFile::save(std::ostream &file) const
{
	file << "Type: Regular" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Content: " << getData() << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void RegularFile::cat() const
{
	for (auto it : *this) // iterator (I know it is not a good way to do this but I wanted to use iterator)
	{
		std::cout << it;
	}
	std::cout << std::endl;
}

// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void RegularFile::cd(Shell &shell) // throws exception because it is not a directory
{
	(void)shell; // unused parameter but I need it to override the virtual function
	throw std::runtime_error("cd :" + getName() + " : Not a directory");
}
Type: Regular
Name: SaveFile.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704806561
Content: #include "../includes/SaveFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include <fstream>
#include <stdexcept>

namespace
{
	// recursive function that saves subdirectories and files
	void recursive(std::ofstream &file, Directory *directory)
	{
		for (auto vfile = directory->getFiles().begin(); vfile != directory->getFiles().end(); ++vfile)
		{
			(*vfile)->save(file);
			if (dynamic_cast<Directory *>(*vfile) != nullptr)
			{
				Directory *vdFile = dynamic_cast<Directory *>(*vfile);
				recursive(file, vdFile);
			}
		}
	}
}

// Precondition: program wants to save the current state of the shell to a file
// Postcondition: the current state of the shell is saved to a file
void SaveFile::save(const std::string &path, Shell &shell)
{
	std::ofstream file(path);
	if (!file.is_open())
	{
		throw std::runtime_error("File cannot be opened!");
	}
	file << "Time: " << shell.getRoot()->getTime() << std::endl;
	for (const auto &vfile : shell.getRoot()->getFiles())
	{
		if (vfile != nullptr)
		{
			vfile->save(file);
			if (dynamic_cast<Directory *>(vfile) != nullptr) // if it is a directory then call recursive function
			{
				Directory *vdFile = dynamic_cast<Directory *>(vfile);
				recursive(file, vdFile); // recursive function
			}
		}
	}
	file.close();
}
Type: Regular
Name: Shell.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704811871
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/SaveFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/Executor.hpp"
#include <fstream>
#include <string>
#include <stdexcept>

const std::string Shell::fileSystemPath = "./os/filesystem.txt";

Shell::Shell() : isTerminating(false), prompt("/$ ")
{
	std::ifstream file(fileSystemPath);
	time_t timeT;
	string timeStr;
	if (!file.is_open())
		throw std::runtime_error("filesystem.txt not found");
	timeStr = Utils::getContent(file);
	timeT = std::stoi(timeStr);
	this->root = new Directory("/", timeT, "/");
	this->currentDirectory = this->root;
	file.close();
}

/* destructor : deletes root directory \
	deleting root directory deletes all files in it recursively. \
	because delete calls each files destructor and deletes them. */
Shell::~Shell()
{
	delete this->root;
}

void Shell::execute(string command)
{
	if (command == "")
		return;
	command = Utils::trim(command);
	vector<string> commandSplit = Utils::split(command, ' ');
	string commandName = commandSplit[0];

	if (commandName == "exit")
	{
		this->setTerminated(true);
		SaveFile::save(Shell::getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "ls")
	{
		if (commandSplit.size() == 1)
			Executor::ls(getCurrentDirectory(), *this, "");
		else if (commandSplit[1] == "-R"){
			Executor::ls(getCurrentDirectory(), *this, commandSplit[1]);
		}
		else
			throw runtime_error("ls: invalid option for cemalBolatShell -- '" + command + "'");
		return;
	}
	else if (commandName == "cat")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cat: invalid number of arguments for cemalBolatShell -- ");
		else
			Executor::cat(*this, commandSplit[1]);
		return;
	}
	else if (commandName == "rm")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("rm: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::rm(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "mkdir")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("mkdir: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::mkdir(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "cd")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cd: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::cd(*this, commandSplit[1]);
			if (getCurrentDirectory()->getName() == "/")
				this->setPrompt("/$ ");
			else
				setPrompt(getCurrentDirectory()->getPath() + getCurrentDirectory()->getName() + "$ ");
			return;
		}
	}
	else if (commandName == "cp")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("cp: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("cp: invalid number of arguments for cemalBolatShell -- ");
		else if (commandSplit[1] == "." || commandSplit[1] == ".." || commandSplit[1] == "/")
			throw runtime_error("cp: cannot copy to " + commandSplit[1] + ": file exists");
		Executor::cp(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "link")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("link: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("link: invalid number of arguments for cemalBolatShell -- ");
		Executor::link(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else
		throw invalid_argument("cemalBolatShell: " + commandName + ": command not found");
}
Type: Regular
Name: SymbolicLink.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704806816
Content: #include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

SymbolicLink::SymbolicLink(const string &name, const string &path, time_t time, File *link, const string &linkedName, const string &linkPath)
	: File(name, time, path), link(link), linkedName(linkedName), linkPath(linkPath)
{ /*Body inintentionally left empty! */
}

SymbolicLink::~SymbolicLink()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void SymbolicLink::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::red();
	os << "L ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << "2 Bytes ";
	Utils::TextEngine::reset();
	Utils::TextEngine::yellow();
	Utils::TextEngine::bold();
	os << this->getName() << " -> " << this->getLinkedPath() + this->getLinkedName();
	Utils::TextEngine::reset();

	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void SymbolicLink::save(std::ostream &file) const
{
	file << "Type: Link" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Link: " << linkPath << std::endl;
	file << "LinkedName: " << linkedName << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void SymbolicLink::cat() const
{
	if (link == nullptr)
	{
		throw std::runtime_error("cat :" + getName() + " : No such file or directory");
	}
	link->cat(); // if link is symbolic link, it will call this function again
}


// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void SymbolicLink::cd(Shell &shell)
{
	if (link == nullptr)
	{
		throw std::runtime_error("cd :" + getName() + " : No such file or directory");
	}
	link->cd(shell); // if link is symbolic link, it will call this function again

Type: Regular
Name: Template.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704801868
Content: #include "../includes/Utils.hpp"
#include "../includes/Directory.hpp"
#include <memory>

template <typename T>
T	*findTraverse(Directory *directory, const vector<string> &path)
{
	for (auto file : *directory){
		if (file->getName() == path[0])
		{
			if (path.size() == 1)
			{
				if (dynamic_cast<T *>(file))
					return dynamic_cast<T *>(file);
			}
			else
			{
				return findTraverse<T>(dynamic_cast<Directory *>(file), vector<string>(path.begin() + 1, path.end()));
			}
		}
	}
	return nullptr;
}

template <>
Directory	*File::find<Directory>(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	if (paths.size() == 0)
	{
		return shell.getRoot();
	}
	return (findTraverse<Directory>(shell.getRoot(), paths));
}

template <typename T>
T	*File::find(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	return (findTraverse<T>(shell.getRoot(), paths));

Type: Regular
Name: TextEngine.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704299052
Content: #include "../includes/TextEngine.hpp"
#include <iostream>
using namespace std;


namespace Utils {
	// namespace : TextEngine is for text coloring in terminal
	namespace TextEngine {
		void	yellow() { cout << ANSI_FG_YELLOW; }
		void	red() { cout << ANSI_FG_RED; }
		void	green() { cout << ANSI_FG_GREEN; }
		void	blue() { cout << ANSI_FG_BLUE; }
		void	reset() {cout << ANSI_RESET; }
		void	bold() { cout << ANSI_BOLD; }
		void	underline() { cout << ANSI_UNDERLINE;}
		void	blink() { cout << ANSI_BLINK;}
		void	black() { cout << ANSI_FG_BLACK; }
		void	magenta() { cout << ANSI_FG_MAGENTA; }
		void	cyan() { cout << ANSI_FG_CYAN; }
		void	white() { cout << ANSI_FG_WHITE; }
		void	redBackground() { cout << ANSI_BG_RED; }
		void	greenBackground() { cout << ANSI_BG_GREEN; }
		void	blueBackground() { cout << ANSI_BG_BLUE; }
		void	yellowBackground() { cout << ANSI_BG_YELLOW; }
		void	blackBackground() { cout << ANSI_BG_BLACK; }
		void	magentaBackground() { cout << ANSI_BG_MAGENTA; }
		void	cyanBackground() { cout << ANSI_BG_CYAN; }
		void	whiteBackground() { cout << ANSI_BG_WHITE; }
		void	resetBackground() { cout << "\033[49m"; }
		void	resetForeground() { cout << "\033[39m"; }
		void	resetAll() { cout << "\033[0m"; }
		void	orange() { cout << "\033[38;5;208m"; }
	}

Type: Regular
Name: Utils.cpp
Path: /gtu/cse/cse108/lab_notes/
Time: 1704806924
Content: #include "../includes/Utils.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include <iomanip>
#include <vector>
#include <sstream>
#include <sys/stat.h>
#include <stdexcept>

using namespace std;

namespace
{
	// Precondition: month is between 1 and 12
	// Postcondition: returns the string of month
	string convertMonth(int month)
	{
		switch (month)
		{
		case 1: return "Jan";
		case 2: return "Feb";
		case 3: return "Mar";
		case 4: return "Apr";
		case 5: return "May";
		case 6: return "Jun";
		case 7: return "Jul";
		case 8: return "Aug";
		case 9: return "Sep";
		case 10: return "Oct";
		case 11: return "Nov";
		default: return "Dec";
		}
	}
}

namespace Utils
{
	// Precondition: str is a string
	// Postcondition: returns the vector of splitted string by delim
	vector<string> split(const string &str, char delim)
	{
		std::vector<std::string> elems;
		std::stringstream ss(str);
		std::string item;
		while (std::getline(ss, item, delim))
		{
			if (!item.empty())
				elems.push_back(item);
		}
		return elems;
	}
	// Precondition: str is a string
	// Postcondition: returns the trimmed string
	string trim(const std::string &str)
	{
		size_t first = str.find_first_not_of(" \t\r");
		size_t last = str.find_last_not_of(" \t\r");

		if (first == std::string::npos || last == std::string::npos)
			return "";

		return str.substr(first, last - first + 1);
	}
	// Precondition : file is a ifstream
	// Postcondition: returns the content of file (without spaces)
	string getContent(std::ifstream &file)
	{
		string content;
		getline(file, content);
		content = trim(content);
		if (content.empty())
			throw runtime_error("File content is not configrated!");
		return content.substr(content.find(" ") + 1, content.size() - 1);
	}
	// Precondition: timeinfo is a struct tm
	// Postcondition: prints the timeinfo to os
	ostream &printTime(ostream &os, struct tm *timeinfo)
	{
		int day = timeinfo->tm_mday;
		int month = timeinfo->tm_mon + 1;
		int hour = timeinfo->tm_hour;
		int minute = timeinfo->tm_min;

		os << std::right << std::setw(3) << std::setfill('0') << convertMonth(month) << " "
		   << std::right << std::setw(2) << std::setfill('0') << day << " "
		   << std::right << std::setw(2) << std::setfill('0') << hour << ":"
		   << std::right << std::setw(2) << std::setfill('0') << minute << " ";
		return os;
	}
	// Precondition: file is a ifstream
	// Postcondition: returns the data of file
	string getData(std::ifstream &file)
	{
		string data;
		string line;
		getline(file, line);
		data = line.substr(line.find(" ") + 1, line.size() - 1);
		if (data[data.size() - 1] == static_cast<char>(3))
		{
			return data;
		}
		data += "\n";
		while (getline(file, line))
		{
			trim(line);
			data += line;
			if (!line.empty() && line[line.size() - 1] == static_cast<char>(3))
			{
				break;
			}
			data += "\n";
		}
		line += static_cast<char>(3);
		return data;
	}
	// Precondition: path is a string
	// Postcondition: returns the absolute path of path
	string relPathToAbsPath(const Shell &shell, const std::string &path)
	{
		string relPathToAbsPath;
		vector<string> relPathToAbsPathSplit;
		vector<string> relPathToAbsPathSplitTmp;
		if (path[0] == '/')
			relPathToAbsPathSplit = Utils::split(path, '/');
		else
		{
			relPathToAbsPathSplit = Utils::split(shell.getCurrentDirectory()->getOwnFilesPath() + "/" + path, '/');
		}
		if (relPathToAbsPathSplit.size() == 0)
			return "/";
		for (auto &path : relPathToAbsPathSplit)
		{
			// std::cout << path << std::endl;
			if (path == ".")
				continue;
			else if (path == "..")
			{
				if (relPathToAbsPathSplitTmp.size() > 0)
					relPathToAbsPathSplitTmp.pop_back();
			}
			else
				relPathToAbsPathSplitTmp.push_back(path);
		}
		relPathToAbsPath = "";
		for (auto &path : relPathToAbsPathSplitTmp)
		{
			relPathToAbsPath += "/" + path;
		}
		if (relPathToAbsPath == "")
			relPathToAbsPath = "/";
		return relPathToAbsPath;
	}

	string getParentPathOfAbsPath(const string &absPath)
	{
		size_t found = absPath.find_last_of('/');
		if (found != std::string::npos)
		{
			if (found == 0)
				return "/";
			return absPath.substr(0, found);
		}
		return "/";
	}
}

namespace Utils
{
	// Precondition: directory is a Directory
	// Postcondition: returns the size of directory recursively
	// Note: size of directory is the sum of size of its files and its subdirectories recursively + 15 is the size of saving system information
	size_t getProgramSize(const Shell &Shell)
	{
		struct stat st;
		stat(Shell.getFileSystemPath().c_str(), &st);
		return st.st_size;
	}
}

namespace Utils
{
	// Precondition: shell is a Shell
	// Postcondition: rechecks the links of shell recursively because of the possibility of deleting linked files or creating new files for linking to them
	void recheckLinks(Shell &shell, Directory *directory)
	{
		for (auto it = directory->getFiles().begin(); it != directory->getFiles().end(); ++it)
		{
			if (dynamic_cast<SymbolicLink *>(*it) != nullptr)
			{ // if file is a symbolic link
				SymbolicLink *link = dynamic_cast<SymbolicLink *>(*it);
				File *linkFile = File::find<File>(shell, link->getLinkedPath() + "/" + link->getLinkedName());
				link->setLink(linkFile);
			}
			else if (dynamic_cast<Directory *>(*it) != nullptr)
			{ // if file is a directory then recursive call
				Directory *dir = dynamic_cast<Directory *>(*it);
				recheckLinks(shell, dir);
			}
		}
	}
}

namespace Utils {
	// prints the prompt properly
	void printPrompt(const Shell &shell) {
		Utils::TextEngine::green();
		Utils::TextEngine::bold();
		cout << "cemalBolat@C++0S:";
		Utils::TextEngine::reset();
		Utils::TextEngine::bold();
		Utils::TextEngine::blue();
		cout << shell.getPrompt();
		Utils::TextEngine::magenta();
	}
}
Type: Directory
Name: phy
Path: /gtu/
Time: 1704813045
Type: Regular
Name: lecture_rlc_notes
Path: /gtu/phy/
Time: 1704572151
Content: NAME := myShell
SRCS := ./src/main.cpp \
		./src/Shell.cpp \
		./src/File.cpp \
		./src/Directory.cpp \
		./src/RegularFile.cpp \
		./src/LoadFile.cpp \
		./src/Utils.cpp \
		./src/Executor.cpp \
		./src/SaveFile.cpp \
		./src/TextEngine.cpp \
		./src/SymbolicLink.cpp \

OBJS := ./obj/main.o \
		./obj/Shell.o \
		./obj/File.o \
		./obj/Directory.o \
		./obj/RegularFile.o \
		./obj/LoadFile.o \
		./obj/Utils.o \
		./obj/Executor.o \
		./obj/SaveFile.o \
		./obj/TextEngine.o \
		./obj/SymbolicLink.o \

CXX := g++
CXXFLAGS := -std=c++11 -pedantic -g -Wall -Wextra -Werror -I./include

all : $(NAME)

$(NAME) : $(OBJS) $(Header)
	$(CXX) $(CXXFLAGS) -o $@ $^

$(OBJS) : ./obj/%.o : ./src/%.cpp
	$(CXX) $(CXXFLAGS) -c -o $@ $<

clean :
	rm -f $(OBJS)

fclean : clean
	rm -f $(NAME)

re : fclean all

.PHONY : all clean fclean re
Type: Directory
Name: 2024
Path: /
Time: 1704812865
Type: Directory
Name: wishlist
Path: /2024/
Time: 1704299052
Type: Regular
Name: Directory.cpp
Path: /2024/wishlist/
Time: 1704802991
Content: #include "../includes/Directory.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/Shell.hpp"
#include <ctime>		// std::localtime
#include <sstream>		// std::stringstream
#include <iomanip>		// std::setw
#include <stdexcept>	// std::runtime_error

// constructor for root directory
Directory::Directory(const string &name, time_t time, const string &path)
	: File(name, time, path), ownFilesPath("/"), parentDirectory(nullptr)
{
	files = vector<File *>();
}

// constructor for other directories
Directory::Directory(const string &name, time_t time, const string &path, Directory *parentDirectory)
	: File(name, time, path), ownFilesPath(path + name + "/"), parentDirectory(parentDirectory)
{
	files = vector<File *>();
}

// destructor : delete calls each files destructor and deletes them.
// then deletes itself.
Directory::~Directory()
{
	for (auto file : this->files)
		delete file;
}

// Preconditions: User wants to add a file to this directory.
// Postconditions: Adds file to files vector. <push_back>
void Directory::addFile(File *file)
{
	this->files.push_back(file);
}

// Preconditions: User wants to print the information about this directory with using ls or something.
// Postconditions: Prints the information about this directory. <colorful way>
void Directory::print(std::ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "D ";
	Utils::TextEngine::reset();
	Utils::TextEngine::bold();
	Utils::TextEngine::cyan();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();

	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::resetAll();
	os << std::endl;
}

// Preconditions : Progaram wants to save this directory to filesystem.txt file.
// Postconditions : Saves this directory to filesystem.txt file.
void Directory::save(std::ostream &file) const
{
	file << "Type: Directory" << std::endl;
	file << "Name: " << this->getName() << std::endl;
	file << "Path: " << this->getPath() << std::endl;
	file << "Time: " << this->getTime() << std::endl;
}

// Preconditions: User wants to cat this directory.
// Postconditions: Throws runtime_error.
void Directory::cat() const
{
	throw std::runtime_error("cat: " + this->getName() + ": Is a directory");
}

// Preconditions: User wants to remove a specific named file from this directory.
// Postconditions: Removes file from files vector and deletes it <erase>
void Directory::removeFile(const string &name)
{
	for (auto it = this->files.begin(); it != this->files.end(); ++it)
	{
		if ((*it)->getName() == name)
		{
			delete *it;
			this->files.erase(it);
			return;
		}
	}
}

// Preconditions: User wants to change current directory to this directory.
// Postconditions: Changes current directory to this directory.
void Directory::cd(Shell &shell)
{
	shell.setCurrentDirectory(this);
}
Type: Regular
Name: Executor.cpp
Path: /2024/wishlist/
Time: 1704810937
Content: #include "../includes/Executor.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/File.hpp"
#include "../includes/Directory.hpp"
#include "./Template.cpp"
#include <ctime>
#include <sys/stat.h>
#include <fstream>
#include <dirent.h>
#include <sys/types.h>
#include <fcntl.h>
#include <iomanip>
#include <cstring>
#include <stdexcept>

//****************************************  LS  ****************************************//
namespace
{

	// Getting absolute path of a file only by its name while listing files
	string absPathToRelPath(const Shell &shell, const string &path)
	{
		return path.substr(shell.getCurrentDirectory()->getOwnFilesPath().size(), path.size() - 1);
	}
	// lisiting only current directory '.'
	void listOnlyCurrentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << "."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
	// listing parent directory '..'
	void listParentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getParentDirectory()->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << ".."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
}

namespace
{
	// returns max name length of files in directory to align
	size_t getMaxNameLength(const Directory *directory)
	{
		size_t maxNameLength = 2; // for '.' and '..'
		for (auto file : *directory)
		{
			if (file->getName().length() > maxNameLength)
				maxNameLength = file->getName().length();
		}
		return maxNameLength;
	}
}

namespace Executor
{
	// Precondition: User wants to execute ls command
	// Postcondition: ls command is executed
	// @param directory: current directory
	// @param option: option for ls command
	/*
		ls command is used to list files and directories in current directory.
		ls command's '-R' option has a special print format. Firstly it prints current directory's files and directories.
		Then it prints subdirectories' files and directories recursively.
	*/
	void ls(const Directory *directory, const Shell &Shell, const string &option)
	{
		size_t	maxNameLength = getMaxNameLength(directory); // for align
		listOnlyCurrentDirectory(cout, directory, maxNameLength); // listing '.' is a must for ls command
		if (directory != Shell.getRoot()) // listing '..' is a must except root directory
			listParentDirectory(cout, directory, maxNameLength);
		for (auto file : *directory)
			file->print(cout, maxNameLength);
		if (option == "-R")
		{
			for (auto file : *directory)
			{
				if (dynamic_cast<Directory *>(file))
				{
					Directory *directory = dynamic_cast<Directory *>(file);
					cout << "\n";
					Utils::TextEngine::orange();
					cout << "./" << absPathToRelPath(Shell, directory->getOwnFilesPath()) << ":";
					Utils::TextEngine::reset();
					cout << endl;
					ls(directory, Shell, option);
				}
			}
		}
	}
}

//****************************************  LS OVER ****************************************//

//****************************************  CAT  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute cat command
	// Postcondition: cat command is executed
	void cat(const Shell &shell, const string &fileName)
	{
		File	*filePtr = nullptr;

		if (fileName.empty())
			throw runtime_error("cat: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cat: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName); // get absolute path of file
			if (absPath == "/")
				throw runtime_error("cat: " + fileName + ": Is a directory"); // root directory cannot be printed
			filePtr = File::find<File>(shell, absPath);
			if (filePtr == nullptr)
				throw invalid_argument("cat: " + fileName + ": No such file or directory");
			filePtr->cat(); // <polymorphism>
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  CAT OVER ****************************************//

//****************************************  RM  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute rm command
	// Postcondition: rm command is executed
	void	rm(const Shell &shell, const string &fileName)
	{
		File		*filePtr = nullptr;
		Directory	*parentDirectory = nullptr;

		if (fileName.empty())
			throw runtime_error("rm: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("rm: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("rm: cannot remove '" + fileName + "': Is a directory"); // root directory cannot be deleted
			filePtr = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absPath));
			if (filePtr == nullptr)
				throw invalid_argument("rm: cannot remove '" + fileName + "': No such file or directory");
			if (dynamic_cast<Directory *>(filePtr))
				throw invalid_argument("rm: cannot remove '" + fileName + "': Is a directory"); // directory cannot be deleted as you said in pdf
			parentDirectory->removeFile(filePtr->getName()); // remove file from parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  RM OVER ****************************************//
//****************************************  MKDIR  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute mkdir command
	// Postcondition: mkdir command is executed
	// @brief : '' Makes or removes a directory '' as pdf says
	void mkdir(const Shell &shell, const string &fileName)
	{
		File		*directory = nullptr;
		Directory	*parentDirectory = nullptr;
		if (fileName.empty())
			throw runtime_error("mkdir: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists"); // root directory cannot be created and deleted
			string pPath = Utils::getParentPathOfAbsPath(absPath);
			if (pPath == "/")
				pPath = ""; // if parent directory is root directory, parent directory's path is empty
			directory = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, pPath);
			if (directory != nullptr) // delete if existent file is directory and throw exception if not
			{
				if (dynamic_cast<Directory *>(directory)) // if file is directory
				{
					parentDirectory->removeFile(absPath.substr(absPath.find_last_of('/') + 1)); // remove directory from parent directory
					parentDirectory->setTime(time(nullptr));
				}
				else
					throw invalid_argument("mkdir: cannot create directory '" + fileName + "': File exists"); // if file is not directory throw exception
				return;
			}
			else if (parentDirectory == nullptr) // if parent directory does not exist throw exception <for root directory parent directory manipulalated as root too at find function>
				throw invalid_argument("mkdir: cannot create directory '" + fileName + "': No such file or directory");
			string name = absPath.substr(absPath.find_last_of('/') + 1);
			if (parentDirectory == shell.getRoot()) // if parent directory is root directory
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath(), parentDirectory);
			else
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath() + parentDirectory->getName() + "/", parentDirectory);
			parentDirectory->addFile(directory); // add directory to parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}
//****************************************  MKDIR OVER ****************************************//
//****************************************  CD  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute cd command
	// Postcondition: cd command is executed
	// @brief : '' Changes the current directory '' as pdf says
	// @brief '.' and '..' are special cases for cd command and empty string is special case for cd command
	// @brief if directory is not existent throw exception
	void	cd(Shell &shell, const string &directoryName)
	{
		File	*directory = nullptr;
		if (directoryName.empty()) // if directory name is empty set current directory to root directory
			shell.setCurrentDirectory(shell.getRoot());
		else if (directoryName == ".") // if directory name is '.' do nothing
			return;
		else if (directoryName == "..") // if directory name is '..' set current directory to parent directory
		{
			if (shell.getCurrentDirectory() == shell.getRoot()) // if current directory is root directory do nothing
				return;
			shell.setCurrentDirectory(shell.getCurrentDirectory()->getParentDirectory());
		}
		else
		{
			try
			{
				string pPath = Utils::relPathToAbsPath(shell, directoryName);
				if (pPath == "/")
				{
					shell.setCurrentDirectory(shell.getRoot());
					return;
				}
				directory = File::find<File>(shell, pPath);
				if (directory == nullptr)
					throw invalid_argument("cd: " + directoryName + ": No such file or directory");
				directory->cd(shell); // <polymorphism>
			}
			catch (const invalid_argument &e)
			{
				throw e;
			}
		}
	}
}

// ****************************************  CD OVER ****************************************//
// ****************************************  CP  ****************************************//

namespace
{
	// Precondition: User wants to execute cp command and source is a regular file
	// Postcondition: cp command is executed and source is copied to destination
	// @brief : '' Copies file and directory from our original os '' as pdf says
	RegularFile	*copyRegularFile(const string &source, const string &fileName, const struct stat &sourceStat, const string &path)
	{
		ifstream	sourceFile(source);
		RegularFile	*regularFile;
		string		data, line;
		if (!sourceFile.is_open())
			throw runtime_error("cp: source file '" + source + "' does not exist");
		while (getline(sourceFile, line)) // read file line by line
		{
			data += line + "\n";
		}
		data = data.substr(0, data.size() - 2);
		data += static_cast<char>(3); // end of text character
		sourceFile.close();
		regularFile = new RegularFile(fileName, data.size(), sourceStat.st_mtime, data, path); // create regular file
		return regularFile;
	}
}

namespace
{
	// Precondition: User wants to execute cp command and source is a directory
	// Postcondition: cp command is executed and source is copied to destination
	Directory *copyDirectory(const string &source, const string &fileName, const Shell &shell, const struct stat &sourceStat, const string &path, Directory *parentDirectory)
	{
		Directory	*directory; // directory to be copied

		DIR *copiedDir = opendir(source.c_str()); // open directory
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		struct dirent *entry; // entry of directory
		directory = new Directory(fileName, sourceStat.st_mtime, path, parentDirectory); // create directory
		while ((entry = readdir(copiedDir)) != nullptr) // read the directory until end
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) // ignore '.' and '..'
			{
				std::string entryPath = source + "/" + entry->d_name; // get entry's path

				struct stat entryStat; // entry's stat
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'"); // if stat cannot be accessed throw exception and exit
				}
				if (S_ISREG(entryStat.st_mode))
				{
					// Copy regular file
					RegularFile *regularFile = copyRegularFile(entryPath, entry->d_name, entryStat, directory->getOwnFilesPath());
					directory->addFile(regularFile); // add regular file to directory
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					// Recursively copy subdirectories
					Directory *subDirectory = copyDirectory(entryPath, entry->d_name, shell, entryStat, directory->getOwnFilesPath(), directory);
					directory->addFile(subDirectory); // add subdirectory to directory
				}
			}
		}
		closedir(copiedDir); // close directory
		return (directory);
	}
}

namespace
{
	// Precondition: User wants to execute cp command so program gets the size of directory
	// Postcondition: Returns the size of directory
	size_t getDirectorySize(const struct stat &sourcestat, const string &source)
	{
		DIR *copiedDir = opendir(source.c_str());
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		(void)sourcestat; // unused
		struct dirent *entry;
		size_t size = 0;
		while ((entry = readdir(copiedDir)) != nullptr)
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0)
			{
				std::string entryPath = source + "/" + entry->d_name;

				struct stat entryStat;
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'");
				}

				if (S_ISREG(entryStat.st_mode))
				{
					size += entryStat.st_size;
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					size += getDirectorySize(entryStat, entryPath); // recursively get subdirectories' size
				}
			}
		}
		closedir(copiedDir);
		return (size);
	}
}

namespace
{
	// Precondition: User wants to execute cp command
	// Postcondition: cp command is executed and source is copied to destination
	void onlyAddToDirectory(const Shell &shell, const string &source, const string &fileName, const struct stat &sourceStat)
	{

		if (S_ISREG(sourceStat.st_mode))
		{
			RegularFile *regularFile = copyRegularFile(source, fileName, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath());
			shell.getCurrentDirectory()->addFile(regularFile);
			shell.getCurrentDirectory()->setTime(time(nullptr));
		}
		else if (S_ISDIR(sourceStat.st_mode))
		{
			Directory *directory = copyDirectory(source, fileName, shell, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath(), shell.getCurrentDirectory());
			shell.getCurrentDirectory()->addFile(directory);
		}
		shell.getCurrentDirectory()->setTime(time(nullptr));
	}
}

namespace Executor
{
	// Precondition: User wants to execute cp command
	// Postcondition: program executes cp command
	void cp(const Shell &shell, const string &source, const string &fileName)
	{

		struct stat	sourceStat;
		File		*file = nullptr;

		if (source.empty() || fileName.empty())
			throw runtime_error("cp: missing operand");
		if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists");
		if (stat(source.c_str(), &sourceStat) != 0)
		{
			throw std::runtime_error("cp: source file '" + source + "' does not exist"); // if stat cannot be accessed throw exception and exit
		}
		file = File::find<File>(shell, shell.getCurrentDirectory()->getOwnFilesPath() + fileName);
		if (file != nullptr)
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists"); // if file exists throw exception
		if (S_ISREG(sourceStat.st_mode) && sourceStat.st_size + Utils::getProgramSize(shell) > shell.getOsSize()) // size of file + size of program > size of os
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		if (S_ISDIR(sourceStat.st_mode) && getDirectorySize(sourceStat, source) + Utils::getProgramSize(shell) > shell.getOsSize())
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		onlyAddToDirectory(shell, source, fileName, sourceStat); // add file to current directory
	}
}

// ****************************************  CP OVER ****************************************//
// ****************************************  LINK  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute link command
	// Postcondition: program executes link command
	void link(const Shell &shell, const string &source, const string &dest)
	{
		Directory		*destDirectory = nullptr;
		Directory		*sourceDirectory = nullptr;
		File			*sourceFile = nullptr;
		File			*destFile = nullptr;
		SymbolicLink	*symbolicLink = nullptr; // symbolic link to be created

		string absSourcePath = Utils::relPathToAbsPath(shell, source);
		string absDestPath = Utils::relPathToAbsPath(shell, dest);
		if (dest.empty() || source.empty())
			throw runtime_error("link: missing operand");
		else if (dest == "." || dest == ".." || dest == "/")
			throw runtime_error("link: cannot create link '" + dest + "': File exists");
		try
		{
			destFile = File::find<File>(shell, absDestPath);
			destDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absDestPath));
			if (destDirectory == nullptr) // if destination directory does not exist throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': No such file or directory");
			if (destFile != nullptr) // if destination file exists throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': File exists");
			sourceFile = File::find<File>(shell, absSourcePath);
			sourceDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absSourcePath));
			if (sourceDirectory == nullptr){
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), Utils::getParentPathOfAbsPath(absSourcePath) + "/");
			}
			else {
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), sourceDirectory->getOwnFilesPath());
			}
			destDirectory->addFile(symbolicLink); // add symbolic link to destination directory
			destDirectory->setTime(time(nullptr)); // set destination directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

// ****************************************  LINK OVER ****************************************//
Type: Regular
Name: File.cpp
Path: /2024/wishlist/
Time: 1704805811
Content: #include "../includes/File.hpp"

File::File(const string &name, time_t time, const string& path)
	: name(name) , path(path) ,time(time)
{/*Body inintentionally left empty! */}


File::~File()
{/*Body inintentionally left empty! */}
Type: Regular
Name: LoadFile.cpp
Path: /2024/wishlist/
Time: 1704806200
Content: #include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include <fstream>
#include <string>
#include <ctime>
#include <sstream>
#include <stdexcept>

using namespace std;

// Precondition: program wants to load regular file
// Postcondition: regular file is loaded
void LoadFile::addRegularFile(Shell &shell, ifstream &file)
{
	string name, path, time, data;
	Directory *directory = shell.getRoot();
	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	data = Utils::getData(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		directory = shell.getRoot();
		directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
		return;
	}
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem may not be configrated ! ");
	directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
}

// Precondition: program wants to load directory
// Postcondition: directory is loaded
void LoadFile::addDirectory(Shell &shell, ifstream &file)
{
	string name, path, time;
	Directory *parentDirectory;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		parentDirectory = shell.getRoot();
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
	else
	{
		parentDirectory = File::find<Directory>(shell, path);
		if (parentDirectory == nullptr)
			throw runtime_error("Directory coould not be found.");
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
}

// Precondition: program wants to load symbolic link
// Postcondition: symbolic link is loaded
void LoadFile::addSymbolicLink(Shell &shell, ifstream &file)
{
	string name, path, time, linkPath, linkerName;
	File *link = nullptr;
	Directory *directory = nullptr;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	linkPath = Utils::getContent(file);
	linkerName = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	link = File::find<File>(shell, linkPath + linkerName);
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem file is broken"); // not configrated
	directory->addFile(new SymbolicLink(name, path, time_t_time, link, linkerName, linkPath));
}

// Precondition: program wants to load file system
// Postcondition: file system is loaded
void LoadFile::load(const std::string &path, Shell &shell)
{
	ifstream file(path);

	if (!file.is_open())
		throw runtime_error("File could not be opened.");
	string lineTmp;			// to ignore first line for roots time
	getline(file, lineTmp); // ignore first line
	while (!file.eof())
	{
		string line;
		getline(file, line);
		line = Utils::trim(line);
		if (line.empty())
			continue;
		if (line.substr(line.find(" ") + 1, line.size() - 1) == "Regular")
		{
			addRegularFile(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Directory")
		{
			addDirectory(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Link")
		{
			addSymbolicLink(shell, file);
		}
		else
		{
			throw runtime_error("Filesystem is not in correct format.");
		}
	}
	Utils::recheckLinks(shell, shell.getRoot()); // recheck links because they may be linked after loading file system
	file.close();
}
Type: Regular
Name: main.cpp
Path: /2024/wishlist/
Time: 1704806226
Content: #include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include <iostream>

int main(){

	try {
		Shell	shell;
		LoadFile::load(shell.getFileSystemPath(), shell); // loading file system
		while (!shell.isTerminated()) {
			try {
				Utils::printPrompt(shell); // printing prompt
				string	command;
				getline(cin, command); // getting command
				Utils::TextEngine::reset();
				shell.execute(command); // executing command
			} catch (const exception& e) {
				Utils::TextEngine::bold();
				Utils::TextEngine::red();
				cerr << e.what();
				Utils::TextEngine::reset();
				cout << endl;
			}
		}
	} catch (const exception& e) {
		Utils::TextEngine::bold();
		Utils::TextEngine::red();
		cerr << e.what();
		Utils::TextEngine::reset();
		cout << endl;
	}
}
Type: Regular
Name: RegularFile.cpp
Path: /2024/wishlist/
Time: 1704806455
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

RegularFile::RegularFile(const string &name, size_t sizeBytes, time_t time, const string &data, const string &path)
	: File(name, time, path), sizeBytes(sizeBytes), data(data)
{ /*Body inintentionally left empty! */
}

RegularFile::~RegularFile()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void RegularFile::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "F ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << this->getSizeBytes() << " Bytes";
	Utils::TextEngine::reset();
	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void RegularFile::save(std::ostream &file) const
{
	file << "Type: Regular" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Content: " << getData() << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void RegularFile::cat() const
{
	for (auto it : *this) // iterator (I know it is not a good way to do this but I wanted to use iterator)
	{
		std::cout << it;
	}
	std::cout << std::endl;
}

// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void RegularFile::cd(Shell &shell) // throws exception because it is not a directory
{
	(void)shell; // unused parameter but I need it to override the virtual function
	throw std::runtime_error("cd :" + getName() + " : Not a directory");
}
Type: Regular
Name: SaveFile.cpp
Path: /2024/wishlist/
Time: 1704806561
Content: #include "../includes/SaveFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include <fstream>
#include <stdexcept>

namespace
{
	// recursive function that saves subdirectories and files
	void recursive(std::ofstream &file, Directory *directory)
	{
		for (auto vfile = directory->getFiles().begin(); vfile != directory->getFiles().end(); ++vfile)
		{
			(*vfile)->save(file);
			if (dynamic_cast<Directory *>(*vfile) != nullptr)
			{
				Directory *vdFile = dynamic_cast<Directory *>(*vfile);
				recursive(file, vdFile);
			}
		}
	}
}

// Precondition: program wants to save the current state of the shell to a file
// Postcondition: the current state of the shell is saved to a file
void SaveFile::save(const std::string &path, Shell &shell)
{
	std::ofstream file(path);
	if (!file.is_open())
	{
		throw std::runtime_error("File cannot be opened!");
	}
	file << "Time: " << shell.getRoot()->getTime() << std::endl;
	for (const auto &vfile : shell.getRoot()->getFiles())
	{
		if (vfile != nullptr)
		{
			vfile->save(file);
			if (dynamic_cast<Directory *>(vfile) != nullptr) // if it is a directory then call recursive function
			{
				Directory *vdFile = dynamic_cast<Directory *>(vfile);
				recursive(file, vdFile); // recursive function
			}
		}
	}
	file.close();
}
Type: Regular
Name: Shell.cpp
Path: /2024/wishlist/
Time: 1704811871
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/SaveFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/Executor.hpp"
#include <fstream>
#include <string>
#include <stdexcept>

const std::string Shell::fileSystemPath = "./os/filesystem.txt";

Shell::Shell() : isTerminating(false), prompt("/$ ")
{
	std::ifstream file(fileSystemPath);
	time_t timeT;
	string timeStr;
	if (!file.is_open())
		throw std::runtime_error("filesystem.txt not found");
	timeStr = Utils::getContent(file);
	timeT = std::stoi(timeStr);
	this->root = new Directory("/", timeT, "/");
	this->currentDirectory = this->root;
	file.close();
}

/* destructor : deletes root directory \
	deleting root directory deletes all files in it recursively. \
	because delete calls each files destructor and deletes them. */
Shell::~Shell()
{
	delete this->root;
}

void Shell::execute(string command)
{
	if (command == "")
		return;
	command = Utils::trim(command);
	vector<string> commandSplit = Utils::split(command, ' ');
	string commandName = commandSplit[0];

	if (commandName == "exit")
	{
		this->setTerminated(true);
		SaveFile::save(Shell::getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "ls")
	{
		if (commandSplit.size() == 1)
			Executor::ls(getCurrentDirectory(), *this, "");
		else if (commandSplit[1] == "-R"){
			Executor::ls(getCurrentDirectory(), *this, commandSplit[1]);
		}
		else
			throw runtime_error("ls: invalid option for cemalBolatShell -- '" + command + "'");
		return;
	}
	else if (commandName == "cat")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cat: invalid number of arguments for cemalBolatShell -- ");
		else
			Executor::cat(*this, commandSplit[1]);
		return;
	}
	else if (commandName == "rm")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("rm: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::rm(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "mkdir")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("mkdir: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::mkdir(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "cd")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cd: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::cd(*this, commandSplit[1]);
			if (getCurrentDirectory()->getName() == "/")
				this->setPrompt("/$ ");
			else
				setPrompt(getCurrentDirectory()->getPath() + getCurrentDirectory()->getName() + "$ ");
			return;
		}
	}
	else if (commandName == "cp")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("cp: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("cp: invalid number of arguments for cemalBolatShell -- ");
		else if (commandSplit[1] == "." || commandSplit[1] == ".." || commandSplit[1] == "/")
			throw runtime_error("cp: cannot copy to " + commandSplit[1] + ": file exists");
		Executor::cp(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "link")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("link: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("link: invalid number of arguments for cemalBolatShell -- ");
		Executor::link(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else
		throw invalid_argument("cemalBolatShell: " + commandName + ": command not found");
}
Type: Regular
Name: SymbolicLink.cpp
Path: /2024/wishlist/
Time: 1704806816
Content: #include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

SymbolicLink::SymbolicLink(const string &name, const string &path, time_t time, File *link, const string &linkedName, const string &linkPath)
	: File(name, time, path), link(link), linkedName(linkedName), linkPath(linkPath)
{ /*Body inintentionally left empty! */
}

SymbolicLink::~SymbolicLink()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void SymbolicLink::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::red();
	os << "L ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << "2 Bytes ";
	Utils::TextEngine::reset();
	Utils::TextEngine::yellow();
	Utils::TextEngine::bold();
	os << this->getName() << " -> " << this->getLinkedPath() + this->getLinkedName();
	Utils::TextEngine::reset();

	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void SymbolicLink::save(std::ostream &file) const
{
	file << "Type: Link" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Link: " << linkPath << std::endl;
	file << "LinkedName: " << linkedName << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void SymbolicLink::cat() const
{
	if (link == nullptr)
	{
		throw std::runtime_error("cat :" + getName() + " : No such file or directory");
	}
	link->cat(); // if link is symbolic link, it will call this function again
}


// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void SymbolicLink::cd(Shell &shell)
{
	if (link == nullptr)
	{
		throw std::runtime_error("cd :" + getName() + " : No such file or directory");
	}
	link->cd(shell); // if link is symbolic link, it will call this function again

Type: Regular
Name: Template.cpp
Path: /2024/wishlist/
Time: 1704801868
Content: #include "../includes/Utils.hpp"
#include "../includes/Directory.hpp"
#include <memory>

template <typename T>
T	*findTraverse(Directory *directory, const vector<string> &path)
{
	for (auto file : *directory){
		if (file->getName() == path[0])
		{
			if (path.size() == 1)
			{
				if (dynamic_cast<T *>(file))
					return dynamic_cast<T *>(file);
			}
			else
			{
				return findTraverse<T>(dynamic_cast<Directory *>(file), vector<string>(path.begin() + 1, path.end()));
			}
		}
	}
	return nullptr;
}

template <>
Directory	*File::find<Directory>(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	if (paths.size() == 0)
	{
		return shell.getRoot();
	}
	return (findTraverse<Directory>(shell.getRoot(), paths));
}

template <typename T>
T	*File::find(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	return (findTraverse<T>(shell.getRoot(), paths));

Type: Regular
Name: TextEngine.cpp
Path: /2024/wishlist/
Time: 1704299052
Content: #include "../includes/TextEngine.hpp"
#include <iostream>
using namespace std;


namespace Utils {
	// namespace : TextEngine is for text coloring in terminal
	namespace TextEngine {
		void	yellow() { cout << ANSI_FG_YELLOW; }
		void	red() { cout << ANSI_FG_RED; }
		void	green() { cout << ANSI_FG_GREEN; }
		void	blue() { cout << ANSI_FG_BLUE; }
		void	reset() {cout << ANSI_RESET; }
		void	bold() { cout << ANSI_BOLD; }
		void	underline() { cout << ANSI_UNDERLINE;}
		void	blink() { cout << ANSI_BLINK;}
		void	black() { cout << ANSI_FG_BLACK; }
		void	magenta() { cout << ANSI_FG_MAGENTA; }
		void	cyan() { cout << ANSI_FG_CYAN; }
		void	white() { cout << ANSI_FG_WHITE; }
		void	redBackground() { cout << ANSI_BG_RED; }
		void	greenBackground() { cout << ANSI_BG_GREEN; }
		void	blueBackground() { cout << ANSI_BG_BLUE; }
		void	yellowBackground() { cout << ANSI_BG_YELLOW; }
		void	blackBackground() { cout << ANSI_BG_BLACK; }
		void	magentaBackground() { cout << ANSI_BG_MAGENTA; }
		void	cyanBackground() { cout << ANSI_BG_CYAN; }
		void	whiteBackground() { cout << ANSI_BG_WHITE; }
		void	resetBackground() { cout << "\033[49m"; }
		void	resetForeground() { cout << "\033[39m"; }
		void	resetAll() { cout << "\033[0m"; }
		void	orange() { cout << "\033[38;5;208m"; }
	}

Type: Regular
Name: Utils.cpp
Path: /2024/wishlist/
Time: 1704806924
Content: #include "../includes/Utils.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include <iomanip>
#include <vector>
#include <sstream>
#include <sys/stat.h>
#include <stdexcept>

using namespace std;

namespace
{
	// Precondition: month is between 1 and 12
	// Postcondition: returns the string of month
	string convertMonth(int month)
	{
		switch (month)
		{
		case 1: return "Jan";
		case 2: return "Feb";
		case 3: return "Mar";
		case 4: return "Apr";
		case 5: return "May";
		case 6: return "Jun";
		case 7: return "Jul";
		case 8: return "Aug";
		case 9: return "Sep";
		case 10: return "Oct";
		case 11: return "Nov";
		default: return "Dec";
		}
	}
}

namespace Utils
{
	// Precondition: str is a string
	// Postcondition: returns the vector of splitted string by delim
	vector<string> split(const string &str, char delim)
	{
		std::vector<std::string> elems;
		std::stringstream ss(str);
		std::string item;
		while (std::getline(ss, item, delim))
		{
			if (!item.empty())
				elems.push_back(item);
		}
		return elems;
	}
	// Precondition: str is a string
	// Postcondition: returns the trimmed string
	string trim(const std::string &str)
	{
		size_t first = str.find_first_not_of(" \t\r");
		size_t last = str.find_last_not_of(" \t\r");

		if (first == std::string::npos || last == std::string::npos)
			return "";

		return str.substr(first, last - first + 1);
	}
	// Precondition : file is a ifstream
	// Postcondition: returns the content of file (without spaces)
	string getContent(std::ifstream &file)
	{
		string content;
		getline(file, content);
		content = trim(content);
		if (content.empty())
			throw runtime_error("File content is not configrated!");
		return content.substr(content.find(" ") + 1, content.size() - 1);
	}
	// Precondition: timeinfo is a struct tm
	// Postcondition: prints the timeinfo to os
	ostream &printTime(ostream &os, struct tm *timeinfo)
	{
		int day = timeinfo->tm_mday;
		int month = timeinfo->tm_mon + 1;
		int hour = timeinfo->tm_hour;
		int minute = timeinfo->tm_min;

		os << std::right << std::setw(3) << std::setfill('0') << convertMonth(month) << " "
		   << std::right << std::setw(2) << std::setfill('0') << day << " "
		   << std::right << std::setw(2) << std::setfill('0') << hour << ":"
		   << std::right << std::setw(2) << std::setfill('0') << minute << " ";
		return os;
	}
	// Precondition: file is a ifstream
	// Postcondition: returns the data of file
	string getData(std::ifstream &file)
	{
		string data;
		string line;
		getline(file, line);
		data = line.substr(line.find(" ") + 1, line.size() - 1);
		if (data[data.size() - 1] == static_cast<char>(3))
		{
			return data;
		}
		data += "\n";
		while (getline(file, line))
		{
			trim(line);
			data += line;
			if (!line.empty() && line[line.size() - 1] == static_cast<char>(3))
			{
				break;
			}
			data += "\n";
		}
		line += static_cast<char>(3);
		return data;
	}
	// Precondition: path is a string
	// Postcondition: returns the absolute path of path
	string relPathToAbsPath(const Shell &shell, const std::string &path)
	{
		string relPathToAbsPath;
		vector<string> relPathToAbsPathSplit;
		vector<string> relPathToAbsPathSplitTmp;
		if (path[0] == '/')
			relPathToAbsPathSplit = Utils::split(path, '/');
		else
		{
			relPathToAbsPathSplit = Utils::split(shell.getCurrentDirectory()->getOwnFilesPath() + "/" + path, '/');
		}
		if (relPathToAbsPathSplit.size() == 0)
			return "/";
		for (auto &path : relPathToAbsPathSplit)
		{
			// std::cout << path << std::endl;
			if (path == ".")
				continue;
			else if (path == "..")
			{
				if (relPathToAbsPathSplitTmp.size() > 0)
					relPathToAbsPathSplitTmp.pop_back();
			}
			else
				relPathToAbsPathSplitTmp.push_back(path);
		}
		relPathToAbsPath = "";
		for (auto &path : relPathToAbsPathSplitTmp)
		{
			relPathToAbsPath += "/" + path;
		}
		if (relPathToAbsPath == "")
			relPathToAbsPath = "/";
		return relPathToAbsPath;
	}

	string getParentPathOfAbsPath(const string &absPath)
	{
		size_t found = absPath.find_last_of('/');
		if (found != std::string::npos)
		{
			if (found == 0)
				return "/";
			return absPath.substr(0, found);
		}
		return "/";
	}
}

namespace Utils
{
	// Precondition: directory is a Directory
	// Postcondition: returns the size of directory recursively
	// Note: size of directory is the sum of size of its files and its subdirectories recursively + 15 is the size of saving system information
	size_t getProgramSize(const Shell &Shell)
	{
		struct stat st;
		stat(Shell.getFileSystemPath().c_str(), &st);
		return st.st_size;
	}
}

namespace Utils
{
	// Precondition: shell is a Shell
	// Postcondition: rechecks the links of shell recursively because of the possibility of deleting linked files or creating new files for linking to them
	void recheckLinks(Shell &shell, Directory *directory)
	{
		for (auto it = directory->getFiles().begin(); it != directory->getFiles().end(); ++it)
		{
			if (dynamic_cast<SymbolicLink *>(*it) != nullptr)
			{ // if file is a symbolic link
				SymbolicLink *link = dynamic_cast<SymbolicLink *>(*it);
				File *linkFile = File::find<File>(shell, link->getLinkedPath() + "/" + link->getLinkedName());
				link->setLink(linkFile);
			}
			else if (dynamic_cast<Directory *>(*it) != nullptr)
			{ // if file is a directory then recursive call
				Directory *dir = dynamic_cast<Directory *>(*it);
				recheckLinks(shell, dir);
			}
		}
	}
}

namespace Utils {
	// prints the prompt properly
	void printPrompt(const Shell &shell) {
		Utils::TextEngine::green();
		Utils::TextEngine::bold();
		cout << "cemalBolat@C++0S:";
		Utils::TextEngine::reset();
		Utils::TextEngine::bold();
		Utils::TextEngine::blue();
		cout << shell.getPrompt();
		Utils::TextEngine::magenta();
	}
}
Type: Link
Name: linkit
Path: /2024/
Time: 1704812788
Link: /2024/
LinkedName: biggest_wish
Type: Link
Name: biggest_wish
Path: /2024/
Time: 1704812865
Link: /2024/wishlist/
LinkedName: main.cpp
Type: Directory
Name: cemal
Path: /
Time: 1704813192
Type: Link
Name: linkedHobby
Path: /cemal/
Time: 1704813163
Link: /cemal/hobies/
LinkedName: Utils.cpp
Type: Directory
Name: hobies
Path: /cemal/
Time: 1704299052
Type: Regular
Name: Directory.cpp
Path: /cemal/hobies/
Time: 1704802991
Content: #include "../includes/Directory.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/Shell.hpp"
#include <ctime>		// std::localtime
#include <sstream>		// std::stringstream
#include <iomanip>		// std::setw
#include <stdexcept>	// std::runtime_error

// constructor for root directory
Directory::Directory(const string &name, time_t time, const string &path)
	: File(name, time, path), ownFilesPath("/"), parentDirectory(nullptr)
{
	files = vector<File *>();
}

// constructor for other directories
Directory::Directory(const string &name, time_t time, const string &path, Directory *parentDirectory)
	: File(name, time, path), ownFilesPath(path + name + "/"), parentDirectory(parentDirectory)
{
	files = vector<File *>();
}

// destructor : delete calls each files destructor and deletes them.
// then deletes itself.
Directory::~Directory()
{
	for (auto file : this->files)
		delete file;
}

// Preconditions: User wants to add a file to this directory.
// Postconditions: Adds file to files vector. <push_back>
void Directory::addFile(File *file)
{
	this->files.push_back(file);
}

// Preconditions: User wants to print the information about this directory with using ls or something.
// Postconditions: Prints the information about this directory. <colorful way>
void Directory::print(std::ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "D ";
	Utils::TextEngine::reset();
	Utils::TextEngine::bold();
	Utils::TextEngine::cyan();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();

	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::resetAll();
	os << std::endl;
}

// Preconditions : Progaram wants to save this directory to filesystem.txt file.
// Postconditions : Saves this directory to filesystem.txt file.
void Directory::save(std::ostream &file) const
{
	file << "Type: Directory" << std::endl;
	file << "Name: " << this->getName() << std::endl;
	file << "Path: " << this->getPath() << std::endl;
	file << "Time: " << this->getTime() << std::endl;
}

// Preconditions: User wants to cat this directory.
// Postconditions: Throws runtime_error.
void Directory::cat() const
{
	throw std::runtime_error("cat: " + this->getName() + ": Is a directory");
}

// Preconditions: User wants to remove a specific named file from this directory.
// Postconditions: Removes file from files vector and deletes it <erase>
void Directory::removeFile(const string &name)
{
	for (auto it = this->files.begin(); it != this->files.end(); ++it)
	{
		if ((*it)->getName() == name)
		{
			delete *it;
			this->files.erase(it);
			return;
		}
	}
}

// Preconditions: User wants to change current directory to this directory.
// Postconditions: Changes current directory to this directory.
void Directory::cd(Shell &shell)
{
	shell.setCurrentDirectory(this);
}
Type: Regular
Name: Executor.cpp
Path: /cemal/hobies/
Time: 1704810937
Content: #include "../includes/Executor.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/File.hpp"
#include "../includes/Directory.hpp"
#include "./Template.cpp"
#include <ctime>
#include <sys/stat.h>
#include <fstream>
#include <dirent.h>
#include <sys/types.h>
#include <fcntl.h>
#include <iomanip>
#include <cstring>
#include <stdexcept>

//****************************************  LS  ****************************************//
namespace
{

	// Getting absolute path of a file only by its name while listing files
	string absPathToRelPath(const Shell &shell, const string &path)
	{
		return path.substr(shell.getCurrentDirectory()->getOwnFilesPath().size(), path.size() - 1);
	}
	// lisiting only current directory '.'
	void listOnlyCurrentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << "."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
	// listing parent directory '..'
	void listParentDirectory(ostream &os, const Directory *dir, size_t maxNameLength)
	{
		time_t rawtime = dir->getParentDirectory()->getTime();
		struct tm *timeinfo = std::localtime(&rawtime);

		os << "D " << std::left << std::setw(maxNameLength) << std::setfill(' ') << ".."
		   << " ";
		Utils::printTime(os, timeinfo) << std::endl;
	}
}

namespace
{
	// returns max name length of files in directory to align
	size_t getMaxNameLength(const Directory *directory)
	{
		size_t maxNameLength = 2; // for '.' and '..'
		for (auto file : *directory)
		{
			if (file->getName().length() > maxNameLength)
				maxNameLength = file->getName().length();
		}
		return maxNameLength;
	}
}

namespace Executor
{
	// Precondition: User wants to execute ls command
	// Postcondition: ls command is executed
	// @param directory: current directory
	// @param option: option for ls command
	/*
		ls command is used to list files and directories in current directory.
		ls command's '-R' option has a special print format. Firstly it prints current directory's files and directories.
		Then it prints subdirectories' files and directories recursively.
	*/
	void ls(const Directory *directory, const Shell &Shell, const string &option)
	{
		size_t	maxNameLength = getMaxNameLength(directory); // for align
		listOnlyCurrentDirectory(cout, directory, maxNameLength); // listing '.' is a must for ls command
		if (directory != Shell.getRoot()) // listing '..' is a must except root directory
			listParentDirectory(cout, directory, maxNameLength);
		for (auto file : *directory)
			file->print(cout, maxNameLength);
		if (option == "-R")
		{
			for (auto file : *directory)
			{
				if (dynamic_cast<Directory *>(file))
				{
					Directory *directory = dynamic_cast<Directory *>(file);
					cout << "\n";
					Utils::TextEngine::orange();
					cout << "./" << absPathToRelPath(Shell, directory->getOwnFilesPath()) << ":";
					Utils::TextEngine::reset();
					cout << endl;
					ls(directory, Shell, option);
				}
			}
		}
	}
}

//****************************************  LS OVER ****************************************//

//****************************************  CAT  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute cat command
	// Postcondition: cat command is executed
	void cat(const Shell &shell, const string &fileName)
	{
		File	*filePtr = nullptr;

		if (fileName.empty())
			throw runtime_error("cat: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cat: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName); // get absolute path of file
			if (absPath == "/")
				throw runtime_error("cat: " + fileName + ": Is a directory"); // root directory cannot be printed
			filePtr = File::find<File>(shell, absPath);
			if (filePtr == nullptr)
				throw invalid_argument("cat: " + fileName + ": No such file or directory");
			filePtr->cat(); // <polymorphism>
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  CAT OVER ****************************************//

//****************************************  RM  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute rm command
	// Postcondition: rm command is executed
	void	rm(const Shell &shell, const string &fileName)
	{
		File		*filePtr = nullptr;
		Directory	*parentDirectory = nullptr;

		if (fileName.empty())
			throw runtime_error("rm: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("rm: " + fileName + ": Is a directory");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("rm: cannot remove '" + fileName + "': Is a directory"); // root directory cannot be deleted
			filePtr = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absPath));
			if (filePtr == nullptr)
				throw invalid_argument("rm: cannot remove '" + fileName + "': No such file or directory");
			if (dynamic_cast<Directory *>(filePtr))
				throw invalid_argument("rm: cannot remove '" + fileName + "': Is a directory"); // directory cannot be deleted as you said in pdf
			parentDirectory->removeFile(filePtr->getName()); // remove file from parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

//****************************************  RM OVER ****************************************//
//****************************************  MKDIR  ****************************************//

namespace Executor
{
	// Precondition: User wants to execute mkdir command
	// Postcondition: mkdir command is executed
	// @brief : '' Makes or removes a directory '' as pdf says
	void mkdir(const Shell &shell, const string &fileName)
	{
		File		*directory = nullptr;
		Directory	*parentDirectory = nullptr;
		if (fileName.empty())
			throw runtime_error("mkdir: missing operand");
		else if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists");
		try
		{
			string absPath = Utils::relPathToAbsPath(shell, fileName);
			if (absPath == "/" || absPath == shell.getCurrentDirectory()->getOwnFilesPath()) // if file is root directory or current directory throw exception
				throw runtime_error("mkdir: cannot create directory '" + fileName + "': File exists"); // root directory cannot be created and deleted
			string pPath = Utils::getParentPathOfAbsPath(absPath);
			if (pPath == "/")
				pPath = ""; // if parent directory is root directory, parent directory's path is empty
			directory = File::find<File>(shell, absPath);
			parentDirectory = File::find<Directory>(shell, pPath);
			if (directory != nullptr) // delete if existent file is directory and throw exception if not
			{
				if (dynamic_cast<Directory *>(directory)) // if file is directory
				{
					parentDirectory->removeFile(absPath.substr(absPath.find_last_of('/') + 1)); // remove directory from parent directory
					parentDirectory->setTime(time(nullptr));
				}
				else
					throw invalid_argument("mkdir: cannot create directory '" + fileName + "': File exists"); // if file is not directory throw exception
				return;
			}
			else if (parentDirectory == nullptr) // if parent directory does not exist throw exception <for root directory parent directory manipulalated as root too at find function>
				throw invalid_argument("mkdir: cannot create directory '" + fileName + "': No such file or directory");
			string name = absPath.substr(absPath.find_last_of('/') + 1);
			if (parentDirectory == shell.getRoot()) // if parent directory is root directory
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath(), parentDirectory);
			else
				directory = new Directory(name,
										  time(nullptr), parentDirectory->getPath() + parentDirectory->getName() + "/", parentDirectory);
			parentDirectory->addFile(directory); // add directory to parent directory
			parentDirectory->setTime(time(nullptr)); // set parent directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}
//****************************************  MKDIR OVER ****************************************//
//****************************************  CD  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute cd command
	// Postcondition: cd command is executed
	// @brief : '' Changes the current directory '' as pdf says
	// @brief '.' and '..' are special cases for cd command and empty string is special case for cd command
	// @brief if directory is not existent throw exception
	void	cd(Shell &shell, const string &directoryName)
	{
		File	*directory = nullptr;
		if (directoryName.empty()) // if directory name is empty set current directory to root directory
			shell.setCurrentDirectory(shell.getRoot());
		else if (directoryName == ".") // if directory name is '.' do nothing
			return;
		else if (directoryName == "..") // if directory name is '..' set current directory to parent directory
		{
			if (shell.getCurrentDirectory() == shell.getRoot()) // if current directory is root directory do nothing
				return;
			shell.setCurrentDirectory(shell.getCurrentDirectory()->getParentDirectory());
		}
		else
		{
			try
			{
				string pPath = Utils::relPathToAbsPath(shell, directoryName);
				if (pPath == "/")
				{
					shell.setCurrentDirectory(shell.getRoot());
					return;
				}
				directory = File::find<File>(shell, pPath);
				if (directory == nullptr)
					throw invalid_argument("cd: " + directoryName + ": No such file or directory");
				directory->cd(shell); // <polymorphism>
			}
			catch (const invalid_argument &e)
			{
				throw e;
			}
		}
	}
}

// ****************************************  CD OVER ****************************************//
// ****************************************  CP  ****************************************//

namespace
{
	// Precondition: User wants to execute cp command and source is a regular file
	// Postcondition: cp command is executed and source is copied to destination
	// @brief : '' Copies file and directory from our original os '' as pdf says
	RegularFile	*copyRegularFile(const string &source, const string &fileName, const struct stat &sourceStat, const string &path)
	{
		ifstream	sourceFile(source);
		RegularFile	*regularFile;
		string		data, line;
		if (!sourceFile.is_open())
			throw runtime_error("cp: source file '" + source + "' does not exist");
		while (getline(sourceFile, line)) // read file line by line
		{
			data += line + "\n";
		}
		data = data.substr(0, data.size() - 2);
		data += static_cast<char>(3); // end of text character
		sourceFile.close();
		regularFile = new RegularFile(fileName, data.size(), sourceStat.st_mtime, data, path); // create regular file
		return regularFile;
	}
}

namespace
{
	// Precondition: User wants to execute cp command and source is a directory
	// Postcondition: cp command is executed and source is copied to destination
	Directory *copyDirectory(const string &source, const string &fileName, const Shell &shell, const struct stat &sourceStat, const string &path, Directory *parentDirectory)
	{
		Directory	*directory; // directory to be copied

		DIR *copiedDir = opendir(source.c_str()); // open directory
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		struct dirent *entry; // entry of directory
		directory = new Directory(fileName, sourceStat.st_mtime, path, parentDirectory); // create directory
		while ((entry = readdir(copiedDir)) != nullptr) // read the directory until end
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) // ignore '.' and '..'
			{
				std::string entryPath = source + "/" + entry->d_name; // get entry's path

				struct stat entryStat; // entry's stat
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'"); // if stat cannot be accessed throw exception and exit
				}
				if (S_ISREG(entryStat.st_mode))
				{
					// Copy regular file
					RegularFile *regularFile = copyRegularFile(entryPath, entry->d_name, entryStat, directory->getOwnFilesPath());
					directory->addFile(regularFile); // add regular file to directory
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					// Recursively copy subdirectories
					Directory *subDirectory = copyDirectory(entryPath, entry->d_name, shell, entryStat, directory->getOwnFilesPath(), directory);
					directory->addFile(subDirectory); // add subdirectory to directory
				}
			}
		}
		closedir(copiedDir); // close directory
		return (directory);
	}
}

namespace
{
	// Precondition: User wants to execute cp command so program gets the size of directory
	// Postcondition: Returns the size of directory
	size_t getDirectorySize(const struct stat &sourcestat, const string &source)
	{
		DIR *copiedDir = opendir(source.c_str());
		if (!copiedDir)
		{
			throw std::runtime_error("cp: cannot open source directory '" + source + "'");
		}
		(void)sourcestat; // unused
		struct dirent *entry;
		size_t size = 0;
		while ((entry = readdir(copiedDir)) != nullptr)
		{
			if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0)
			{
				std::string entryPath = source + "/" + entry->d_name;

				struct stat entryStat;
				if (stat(entryPath.c_str(), &entryStat) != 0)
				{
					throw std::runtime_error("cp: error accessing file '" + entryPath + "'");
				}

				if (S_ISREG(entryStat.st_mode))
				{
					size += entryStat.st_size;
				}
				else if (S_ISDIR(entryStat.st_mode))
				{
					size += getDirectorySize(entryStat, entryPath); // recursively get subdirectories' size
				}
			}
		}
		closedir(copiedDir);
		return (size);
	}
}

namespace
{
	// Precondition: User wants to execute cp command
	// Postcondition: cp command is executed and source is copied to destination
	void onlyAddToDirectory(const Shell &shell, const string &source, const string &fileName, const struct stat &sourceStat)
	{

		if (S_ISREG(sourceStat.st_mode))
		{
			RegularFile *regularFile = copyRegularFile(source, fileName, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath());
			shell.getCurrentDirectory()->addFile(regularFile);
			shell.getCurrentDirectory()->setTime(time(nullptr));
		}
		else if (S_ISDIR(sourceStat.st_mode))
		{
			Directory *directory = copyDirectory(source, fileName, shell, sourceStat, shell.getCurrentDirectory()->getOwnFilesPath(), shell.getCurrentDirectory());
			shell.getCurrentDirectory()->addFile(directory);
		}
		shell.getCurrentDirectory()->setTime(time(nullptr));
	}
}

namespace Executor
{
	// Precondition: User wants to execute cp command
	// Postcondition: program executes cp command
	void cp(const Shell &shell, const string &source, const string &fileName)
	{

		struct stat	sourceStat;
		File		*file = nullptr;

		if (source.empty() || fileName.empty())
			throw runtime_error("cp: missing operand");
		if (fileName == "." || fileName == ".." || fileName == "/")
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists");
		if (stat(source.c_str(), &sourceStat) != 0)
		{
			throw std::runtime_error("cp: source file '" + source + "' does not exist"); // if stat cannot be accessed throw exception and exit
		}
		file = File::find<File>(shell, shell.getCurrentDirectory()->getOwnFilesPath() + fileName);
		if (file != nullptr)
			throw runtime_error("cp: cannot copy to '" + fileName + "': File exists"); // if file exists throw exception
		if (S_ISREG(sourceStat.st_mode) && sourceStat.st_size + Utils::getProgramSize(shell) > shell.getOsSize()) // size of file + size of program > size of os
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		if (S_ISDIR(sourceStat.st_mode) && getDirectorySize(sourceStat, source) + Utils::getProgramSize(shell) > shell.getOsSize())
			throw runtime_error("cp: cannot copy '" + source + "': No space left on device");
		onlyAddToDirectory(shell, source, fileName, sourceStat); // add file to current directory
	}
}

// ****************************************  CP OVER ****************************************//
// ****************************************  LINK  ****************************************//
namespace Executor
{
	// Precondition: User wants to execute link command
	// Postcondition: program executes link command
	void link(const Shell &shell, const string &source, const string &dest)
	{
		Directory		*destDirectory = nullptr;
		Directory		*sourceDirectory = nullptr;
		File			*sourceFile = nullptr;
		File			*destFile = nullptr;
		SymbolicLink	*symbolicLink = nullptr; // symbolic link to be created

		string absSourcePath = Utils::relPathToAbsPath(shell, source);
		string absDestPath = Utils::relPathToAbsPath(shell, dest);
		if (dest.empty() || source.empty())
			throw runtime_error("link: missing operand");
		else if (dest == "." || dest == ".." || dest == "/")
			throw runtime_error("link: cannot create link '" + dest + "': File exists");
		try
		{
			destFile = File::find<File>(shell, absDestPath);
			destDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absDestPath));
			if (destDirectory == nullptr) // if destination directory does not exist throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': No such file or directory");
			if (destFile != nullptr) // if destination file exists throw exception
				throw invalid_argument("link: cannot create link '" + dest + "': File exists");
			sourceFile = File::find<File>(shell, absSourcePath);
			sourceDirectory = File::find<Directory>(shell, Utils::getParentPathOfAbsPath(absSourcePath));
			if (sourceDirectory == nullptr){
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), Utils::getParentPathOfAbsPath(absSourcePath) + "/");
			}
			else {
				symbolicLink = new SymbolicLink(absDestPath.substr(absDestPath.find_last_of('/') + 1), destDirectory->getOwnFilesPath(), time(nullptr), sourceFile,
											absSourcePath.substr(absSourcePath.find_last_of('/') + 1), sourceDirectory->getOwnFilesPath());
			}
			destDirectory->addFile(symbolicLink); // add symbolic link to destination directory
			destDirectory->setTime(time(nullptr)); // set destination directory's time to current time to show that it is modified
		}
		catch (const invalid_argument &e)
		{
			throw e;
		}
	}
}

// ****************************************  LINK OVER ****************************************//
Type: Regular
Name: File.cpp
Path: /cemal/hobies/
Time: 1704805811
Content: #include "../includes/File.hpp"

File::File(const string &name, time_t time, const string& path)
	: name(name) , path(path) ,time(time)
{/*Body inintentionally left empty! */}


File::~File()
{/*Body inintentionally left empty! */}
Type: Regular
Name: LoadFile.cpp
Path: /cemal/hobies/
Time: 1704806200
Content: #include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include <fstream>
#include <string>
#include <ctime>
#include <sstream>
#include <stdexcept>

using namespace std;

// Precondition: program wants to load regular file
// Postcondition: regular file is loaded
void LoadFile::addRegularFile(Shell &shell, ifstream &file)
{
	string name, path, time, data;
	Directory *directory = shell.getRoot();
	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	data = Utils::getData(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		directory = shell.getRoot();
		directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
		return;
	}
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem may not be configrated ! ");
	directory->addFile(new RegularFile(name, data.size(), time_t_time, data, path));
}

// Precondition: program wants to load directory
// Postcondition: directory is loaded
void LoadFile::addDirectory(Shell &shell, ifstream &file)
{
	string name, path, time;
	Directory *parentDirectory;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	if (path == "/")
	{
		parentDirectory = shell.getRoot();
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
	else
	{
		parentDirectory = File::find<Directory>(shell, path);
		if (parentDirectory == nullptr)
			throw runtime_error("Directory coould not be found.");
		parentDirectory->addFile(new Directory(name, time_t_time, path, parentDirectory));
	}
}

// Precondition: program wants to load symbolic link
// Postcondition: symbolic link is loaded
void LoadFile::addSymbolicLink(Shell &shell, ifstream &file)
{
	string name, path, time, linkPath, linkerName;
	File *link = nullptr;
	Directory *directory = nullptr;

	name = Utils::getContent(file);
	path = Utils::getContent(file);
	time = Utils::getContent(file);
	linkPath = Utils::getContent(file);
	linkerName = Utils::getContent(file);

	time_t time_t_time = stoi(time);

	link = File::find<File>(shell, linkPath + linkerName);
	directory = File::find<Directory>(shell, path);

	if (directory == nullptr)
		throw runtime_error("Filesystem file is broken"); // not configrated
	directory->addFile(new SymbolicLink(name, path, time_t_time, link, linkerName, linkPath));
}

// Precondition: program wants to load file system
// Postcondition: file system is loaded
void LoadFile::load(const std::string &path, Shell &shell)
{
	ifstream file(path);

	if (!file.is_open())
		throw runtime_error("File could not be opened.");
	string lineTmp;			// to ignore first line for roots time
	getline(file, lineTmp); // ignore first line
	while (!file.eof())
	{
		string line;
		getline(file, line);
		line = Utils::trim(line);
		if (line.empty())
			continue;
		if (line.substr(line.find(" ") + 1, line.size() - 1) == "Regular")
		{
			addRegularFile(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Directory")
		{
			addDirectory(shell, file);
		}
		else if (line.substr(line.find(" ") + 1, line.size() - 1) == "Link")
		{
			addSymbolicLink(shell, file);
		}
		else
		{
			throw runtime_error("Filesystem is not in correct format.");
		}
	}
	Utils::recheckLinks(shell, shell.getRoot()); // recheck links because they may be linked after loading file system
	file.close();
}
Type: Regular
Name: main.cpp
Path: /cemal/hobies/
Time: 1704806226
Content: #include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/LoadFile.hpp"
#include "../includes/Shell.hpp"
#include <iostream>

int main(){

	try {
		Shell	shell;
		LoadFile::load(shell.getFileSystemPath(), shell); // loading file system
		while (!shell.isTerminated()) {
			try {
				Utils::printPrompt(shell); // printing prompt
				string	command;
				getline(cin, command); // getting command
				Utils::TextEngine::reset();
				shell.execute(command); // executing command
			} catch (const exception& e) {
				Utils::TextEngine::bold();
				Utils::TextEngine::red();
				cerr << e.what();
				Utils::TextEngine::reset();
				cout << endl;
			}
		}
	} catch (const exception& e) {
		Utils::TextEngine::bold();
		Utils::TextEngine::red();
		cerr << e.what();
		Utils::TextEngine::reset();
		cout << endl;
	}
}
Type: Regular
Name: RegularFile.cpp
Path: /cemal/hobies/
Time: 1704806455
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

RegularFile::RegularFile(const string &name, size_t sizeBytes, time_t time, const string &data, const string &path)
	: File(name, time, path), sizeBytes(sizeBytes), data(data)
{ /*Body inintentionally left empty! */
}

RegularFile::~RegularFile()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void RegularFile::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::yellow();
	os << "F ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << this->getSizeBytes() << " Bytes";
	Utils::TextEngine::reset();
	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void RegularFile::save(std::ostream &file) const
{
	file << "Type: Regular" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Content: " << getData() << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void RegularFile::cat() const
{
	for (auto it : *this) // iterator (I know it is not a good way to do this but I wanted to use iterator)
	{
		std::cout << it;
	}
	std::cout << std::endl;
}

// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void RegularFile::cd(Shell &shell) // throws exception because it is not a directory
{
	(void)shell; // unused parameter but I need it to override the virtual function
	throw std::runtime_error("cd :" + getName() + " : Not a directory");
}
Type: Regular
Name: SaveFile.cpp
Path: /cemal/hobies/
Time: 1704806561
Content: #include "../includes/SaveFile.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include "../includes/RegularFile.hpp"
#include <fstream>
#include <stdexcept>

namespace
{
	// recursive function that saves subdirectories and files
	void recursive(std::ofstream &file, Directory *directory)
	{
		for (auto vfile = directory->getFiles().begin(); vfile != directory->getFiles().end(); ++vfile)
		{
			(*vfile)->save(file);
			if (dynamic_cast<Directory *>(*vfile) != nullptr)
			{
				Directory *vdFile = dynamic_cast<Directory *>(*vfile);
				recursive(file, vdFile);
			}
		}
	}
}

// Precondition: program wants to save the current state of the shell to a file
// Postcondition: the current state of the shell is saved to a file
void SaveFile::save(const std::string &path, Shell &shell)
{
	std::ofstream file(path);
	if (!file.is_open())
	{
		throw std::runtime_error("File cannot be opened!");
	}
	file << "Time: " << shell.getRoot()->getTime() << std::endl;
	for (const auto &vfile : shell.getRoot()->getFiles())
	{
		if (vfile != nullptr)
		{
			vfile->save(file);
			if (dynamic_cast<Directory *>(vfile) != nullptr) // if it is a directory then call recursive function
			{
				Directory *vdFile = dynamic_cast<Directory *>(vfile);
				recursive(file, vdFile); // recursive function
			}
		}
	}
	file.close();
}
Type: Regular
Name: Shell.cpp
Path: /cemal/hobies/
Time: 1704811871
Content: #include "../includes/RegularFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/SaveFile.hpp"
#include "../includes/Utils.hpp"
#include "../includes/Executor.hpp"
#include <fstream>
#include <string>
#include <stdexcept>

const std::string Shell::fileSystemPath = "./os/filesystem.txt";

Shell::Shell() : isTerminating(false), prompt("/$ ")
{
	std::ifstream file(fileSystemPath);
	time_t timeT;
	string timeStr;
	if (!file.is_open())
		throw std::runtime_error("filesystem.txt not found");
	timeStr = Utils::getContent(file);
	timeT = std::stoi(timeStr);
	this->root = new Directory("/", timeT, "/");
	this->currentDirectory = this->root;
	file.close();
}

/* destructor : deletes root directory \
	deleting root directory deletes all files in it recursively. \
	because delete calls each files destructor and deletes them. */
Shell::~Shell()
{
	delete this->root;
}

void Shell::execute(string command)
{
	if (command == "")
		return;
	command = Utils::trim(command);
	vector<string> commandSplit = Utils::split(command, ' ');
	string commandName = commandSplit[0];

	if (commandName == "exit")
	{
		this->setTerminated(true);
		SaveFile::save(Shell::getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "ls")
	{
		if (commandSplit.size() == 1)
			Executor::ls(getCurrentDirectory(), *this, "");
		else if (commandSplit[1] == "-R"){
			Executor::ls(getCurrentDirectory(), *this, commandSplit[1]);
		}
		else
			throw runtime_error("ls: invalid option for cemalBolatShell -- '" + command + "'");
		return;
	}
	else if (commandName == "cat")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cat: invalid number of arguments for cemalBolatShell -- ");
		else
			Executor::cat(*this, commandSplit[1]);
		return;
	}
	else if (commandName == "rm")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("rm: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::rm(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "mkdir")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("mkdir: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::mkdir(*this, commandSplit[1]);
			Utils::recheckLinks(*this, getRoot());
			SaveFile::save(getFileSystemPath(), *this);
			return;
		}
	}
	else if (commandName == "cd")
	{
		if (commandSplit.size() > 2)
			throw runtime_error("cd: invalid number of arguments for cemalBolatShell -- ");
		else
		{
			Executor::cd(*this, commandSplit[1]);
			if (getCurrentDirectory()->getName() == "/")
				this->setPrompt("/$ ");
			else
				setPrompt(getCurrentDirectory()->getPath() + getCurrentDirectory()->getName() + "$ ");
			return;
		}
	}
	else if (commandName == "cp")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("cp: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("cp: invalid number of arguments for cemalBolatShell -- ");
		else if (commandSplit[1] == "." || commandSplit[1] == ".." || commandSplit[1] == "/")
			throw runtime_error("cp: cannot copy to " + commandSplit[1] + ": file exists");
		Executor::cp(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else if (commandName == "link")
	{
		if (commandSplit.size() < 3)
			throw runtime_error("link: missing operand");
		else if (commandSplit.size() > 3)
			throw runtime_error("link: invalid number of arguments for cemalBolatShell -- ");
		Executor::link(*this, commandSplit[1], commandSplit[2]);
		Utils::recheckLinks(*this, getRoot());
		SaveFile::save(getFileSystemPath(), *this);
		return;
	}
	else
		throw invalid_argument("cemalBolatShell: " + commandName + ": command not found");
}
Type: Regular
Name: SymbolicLink.cpp
Path: /cemal/hobies/
Time: 1704806816
Content: #include "../includes/SymbolicLink.hpp"
#include "../includes/Utils.hpp"
#include "../includes/TextEngine.hpp"
#include <ctime>
#include <iomanip>
#include <stdexcept>

SymbolicLink::SymbolicLink(const string &name, const string &path, time_t time, File *link, const string &linkedName, const string &linkPath)
	: File(name, time, path), link(link), linkedName(linkedName), linkPath(linkPath)
{ /*Body inintentionally left empty! */
}

SymbolicLink::~SymbolicLink()
{ /*Body inintentionally left empty! */}

// Preconditions: User wants to print the information about this file with using ls or something.
// Postconditions: Prints the information about this file. <colorful way>
void SymbolicLink::print(ostream &os, size_t maxLen) const
{
	time_t rawtime = this->getTime();
	struct tm *timeinfo = std::localtime(&rawtime);

	Utils::TextEngine::red();
	os << "L ";
	Utils::TextEngine::bold();
	Utils::TextEngine::orange();
	os << std::left << std::setw(maxLen) << std::setfill(' ') << this->getName() << " ";
	Utils::TextEngine::reset();
	Utils::TextEngine::green();
	Utils::printTime(os, timeinfo);
	Utils::TextEngine::cyan();
	os << "2 Bytes ";
	Utils::TextEngine::reset();
	Utils::TextEngine::yellow();
	Utils::TextEngine::bold();
	os << this->getName() << " -> " << this->getLinkedPath() + this->getLinkedName();
	Utils::TextEngine::reset();

	os << endl;
}

// Preconditions : Progaram wants to save this file to filesystem.txt file.
// Postconditions : Saves this file to filesystem.txt file.
void SymbolicLink::save(std::ostream &file) const
{
	file << "Type: Link" << std::endl;
	file << "Name: " << getName() << std::endl;
	file << "Path: " << getPath() << std::endl;
	file << "Time: " << getTime() << std::endl;
	file << "Link: " << linkPath << std::endl;
	file << "LinkedName: " << linkedName << std::endl;
}

// Preconditions: User wants to print the content of this file.
// Postconditions: Prints the content of this file.
void SymbolicLink::cat() const
{
	if (link == nullptr)
	{
		throw std::runtime_error("cat :" + getName() + " : No such file or directory");
	}
	link->cat(); // if link is symbolic link, it will call this function again
}


// Preconditions: User wants to cd this file.
// Postconditions: Throws exception because it is not a directory.
void SymbolicLink::cd(Shell &shell)
{
	if (link == nullptr)
	{
		throw std::runtime_error("cd :" + getName() + " : No such file or directory");
	}
	link->cd(shell); // if link is symbolic link, it will call this function again

Type: Regular
Name: Template.cpp
Path: /cemal/hobies/
Time: 1704801868
Content: #include "../includes/Utils.hpp"
#include "../includes/Directory.hpp"
#include <memory>

template <typename T>
T	*findTraverse(Directory *directory, const vector<string> &path)
{
	for (auto file : *directory){
		if (file->getName() == path[0])
		{
			if (path.size() == 1)
			{
				if (dynamic_cast<T *>(file))
					return dynamic_cast<T *>(file);
			}
			else
			{
				return findTraverse<T>(dynamic_cast<Directory *>(file), vector<string>(path.begin() + 1, path.end()));
			}
		}
	}
	return nullptr;
}

template <>
Directory	*File::find<Directory>(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	if (paths.size() == 0)
	{
		return shell.getRoot();
	}
	return (findTraverse<Directory>(shell.getRoot(), paths));
}

template <typename T>
T	*File::find(const Shell &shell, const string &path)
{
	vector<string> paths = Utils::split(path, '/'); // **
	return (findTraverse<T>(shell.getRoot(), paths));

Type: Regular
Name: TextEngine.cpp
Path: /cemal/hobies/
Time: 1704299052
Content: #include "../includes/TextEngine.hpp"
#include <iostream>
using namespace std;


namespace Utils {
	// namespace : TextEngine is for text coloring in terminal
	namespace TextEngine {
		void	yellow() { cout << ANSI_FG_YELLOW; }
		void	red() { cout << ANSI_FG_RED; }
		void	green() { cout << ANSI_FG_GREEN; }
		void	blue() { cout << ANSI_FG_BLUE; }
		void	reset() {cout << ANSI_RESET; }
		void	bold() { cout << ANSI_BOLD; }
		void	underline() { cout << ANSI_UNDERLINE;}
		void	blink() { cout << ANSI_BLINK;}
		void	black() { cout << ANSI_FG_BLACK; }
		void	magenta() { cout << ANSI_FG_MAGENTA; }
		void	cyan() { cout << ANSI_FG_CYAN; }
		void	white() { cout << ANSI_FG_WHITE; }
		void	redBackground() { cout << ANSI_BG_RED; }
		void	greenBackground() { cout << ANSI_BG_GREEN; }
		void	blueBackground() { cout << ANSI_BG_BLUE; }
		void	yellowBackground() { cout << ANSI_BG_YELLOW; }
		void	blackBackground() { cout << ANSI_BG_BLACK; }
		void	magentaBackground() { cout << ANSI_BG_MAGENTA; }
		void	cyanBackground() { cout << ANSI_BG_CYAN; }
		void	whiteBackground() { cout << ANSI_BG_WHITE; }
		void	resetBackground() { cout << "\033[49m"; }
		void	resetForeground() { cout << "\033[39m"; }
		void	resetAll() { cout << "\033[0m"; }
		void	orange() { cout << "\033[38;5;208m"; }
	}

Type: Regular
Name: Utils.cpp
Path: /cemal/hobies/
Time: 1704806924
Content: #include "../includes/Utils.hpp"
#include "../includes/RegularFile.hpp"
#include "../includes/TextEngine.hpp"
#include "../includes/SymbolicLink.hpp"
#include "../includes/Shell.hpp"
#include <iomanip>
#include <vector>
#include <sstream>
#include <sys/stat.h>
#include <stdexcept>

using namespace std;

namespace
{
	// Precondition: month is between 1 and 12
	// Postcondition: returns the string of month
	string convertMonth(int month)
	{
		switch (month)
		{
		case 1: return "Jan";
		case 2: return "Feb";
		case 3: return "Mar";
		case 4: return "Apr";
		case 5: return "May";
		case 6: return "Jun";
		case 7: return "Jul";
		case 8: return "Aug";
		case 9: return "Sep";
		case 10: return "Oct";
		case 11: return "Nov";
		default: return "Dec";
		}
	}
}

namespace Utils
{
	// Precondition: str is a string
	// Postcondition: returns the vector of splitted string by delim
	vector<string> split(const string &str, char delim)
	{
		std::vector<std::string> elems;
		std::stringstream ss(str);
		std::string item;
		while (std::getline(ss, item, delim))
		{
			if (!item.empty())
				elems.push_back(item);
		}
		return elems;
	}
	// Precondition: str is a string
	// Postcondition: returns the trimmed string
	string trim(const std::string &str)
	{
		size_t first = str.find_first_not_of(" \t\r");
		size_t last = str.find_last_not_of(" \t\r");

		if (first == std::string::npos || last == std::string::npos)
			return "";

		return str.substr(first, last - first + 1);
	}
	// Precondition : file is a ifstream
	// Postcondition: returns the content of file (without spaces)
	string getContent(std::ifstream &file)
	{
		string content;
		getline(file, content);
		content = trim(content);
		if (content.empty())
			throw runtime_error("File content is not configrated!");
		return content.substr(content.find(" ") + 1, content.size() - 1);
	}
	// Precondition: timeinfo is a struct tm
	// Postcondition: prints the timeinfo to os
	ostream &printTime(ostream &os, struct tm *timeinfo)
	{
		int day = timeinfo->tm_mday;
		int month = timeinfo->tm_mon + 1;
		int hour = timeinfo->tm_hour;
		int minute = timeinfo->tm_min;

		os << std::right << std::setw(3) << std::setfill('0') << convertMonth(month) << " "
		   << std::right << std::setw(2) << std::setfill('0') << day << " "
		   << std::right << std::setw(2) << std::setfill('0') << hour << ":"
		   << std::right << std::setw(2) << std::setfill('0') << minute << " ";
		return os;
	}
	// Precondition: file is a ifstream
	// Postcondition: returns the data of file
	string getData(std::ifstream &file)
	{
		string data;
		string line;
		getline(file, line);
		data = line.substr(line.find(" ") + 1, line.size() - 1);
		if (data[data.size() - 1] == static_cast<char>(3))
		{
			return data;
		}
		data += "\n";
		while (getline(file, line))
		{
			trim(line);
			data += line;
			if (!line.empty() && line[line.size() - 1] == static_cast<char>(3))
			{
				break;
			}
			data += "\n";
		}
		line += static_cast<char>(3);
		return data;
	}
	// Precondition: path is a string
	// Postcondition: returns the absolute path of path
	string relPathToAbsPath(const Shell &shell, const std::string &path)
	{
		string relPathToAbsPath;
		vector<string> relPathToAbsPathSplit;
		vector<string> relPathToAbsPathSplitTmp;
		if (path[0] == '/')
			relPathToAbsPathSplit = Utils::split(path, '/');
		else
		{
			relPathToAbsPathSplit = Utils::split(shell.getCurrentDirectory()->getOwnFilesPath() + "/" + path, '/');
		}
		if (relPathToAbsPathSplit.size() == 0)
			return "/";
		for (auto &path : relPathToAbsPathSplit)
		{
			// std::cout << path << std::endl;
			if (path == ".")
				continue;
			else if (path == "..")
			{
				if (relPathToAbsPathSplitTmp.size() > 0)
					relPathToAbsPathSplitTmp.pop_back();
			}
			else
				relPathToAbsPathSplitTmp.push_back(path);
		}
		relPathToAbsPath = "";
		for (auto &path : relPathToAbsPathSplitTmp)
		{
			relPathToAbsPath += "/" + path;
		}
		if (relPathToAbsPath == "")
			relPathToAbsPath = "/";
		return relPathToAbsPath;
	}

	string getParentPathOfAbsPath(const string &absPath)
	{
		size_t found = absPath.find_last_of('/');
		if (found != std::string::npos)
		{
			if (found == 0)
				return "/";
			return absPath.substr(0, found);
		}
		return "/";
	}
}

namespace Utils
{
	// Precondition: directory is a Directory
	// Postcondition: returns the size of directory recursively
	// Note: size of directory is the sum of size of its files and its subdirectories recursively + 15 is the size of saving system information
	size_t getProgramSize(const Shell &Shell)
	{
		struct stat st;
		stat(Shell.getFileSystemPath().c_str(), &st);
		return st.st_size;
	}
}

namespace Utils
{
	// Precondition: shell is a Shell
	// Postcondition: rechecks the links of shell recursively because of the possibility of deleting linked files or creating new files for linking to them
	void recheckLinks(Shell &shell, Directory *directory)
	{
		for (auto it = directory->getFiles().begin(); it != directory->getFiles().end(); ++it)
		{
			if (dynamic_cast<SymbolicLink *>(*it) != nullptr)
			{ // if file is a symbolic link
				SymbolicLink *link = dynamic_cast<SymbolicLink *>(*it);
				File *linkFile = File::find<File>(shell, link->getLinkedPath() + "/" + link->getLinkedName());
				link->setLink(linkFile);
			}
			else if (dynamic_cast<Directory *>(*it) != nullptr)
			{ // if file is a directory then recursive call
				Directory *dir = dynamic_cast<Directory *>(*it);
				recheckLinks(shell, dir);
			}
		}
	}
}

namespace Utils {
	// prints the prompt properly
	void printPrompt(const Shell &shell) {
		Utils::TextEngine::green();
		Utils::TextEngine::bold();
		cout << "cemalBolat@C++0S:";
		Utils::TextEngine::reset();
		Utils::TextEngine::bold();
		Utils::TextEngine::blue();
		cout << shell.getPrompt();
		Utils::TextEngine::magenta();
	}
}
Type: Link
Name: wish_dir
Path: /
Time: 1704813235
Link: /2024/
LinkedName: wishlist
Type: Link
Name: besthobby
Path: /
Time: 1704813260
Link: /cemal/
LinkedName: linkedHobby
Type: Link
Name: phy_notes
Path: /
Time: 1704813296
Link: /gtu/phy/
LinkedName: lecture_rlc_notes
Type: Link
Name: cse101notes
Path: /
Time: 1704813318
Link: /gtu/cse/cse101/
LinkedName: hw_notes
Type: Regular
Name: baha
Path: /
Time: 1715008597
Content: 
Type: Regular
Name: 31
Path: /
Time: 1715008602
Content: baha
Type: Regular
Name: bahas
Path: /
Time: 1715008611
Content: 31
Type: Regular
Name: annn
Path: /
Time: 1715008626
Content: cemal

Type: Regular
Name: sok
Path: /
Time: 1715008666
Content: arka
